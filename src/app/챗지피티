ÏßÄÍ∏à ÎÇ¥ ÌîåÎû´ÌèºÏùÑ ÌèâÍ∞ÄÌï¥Ï§ò.

ÎÇ¥Í∞Ä ÏßÄÍ∏à ÎπÑÌà¨ÎπÑ Ïö©, Í∑∏Îü¨ÎãàÍπå Î¶¨Í∑∏/Íµ¨Îã®, Ïù¥Î≤§Ìä∏ Ïö¥ÏòÅÏûê Îì§ÏùÑ ÏúÑÌïú ÏßÄÎèÑ Í∏∞Î∞ò Ïä§Ìè¨Ï∏† Ïù¥Î≤§Ìä∏Î•º ÎßåÎì§Í≥† ÏûàÏñ¥. Ïù¥ÌîºÏóò, Ï±îÌîºÏñ∏ÏâΩ, efl1, efl2, ÏòÅÍµ≠Î¶¨Í∑∏ÎÜçÍµ¨, ÌîÑÎ¶¨ÎØ∏Ïñ¥ÏâΩ Îü≠ÎπÑ, ÏòÅÍµ≠ÏóêÏÑúÎßå Ïó¥Î¶¨Îäî ÌÖåÎãàÏä§ÏôÄ Îã§Ìä∏, Í≤ΩÎßà(ÏòÅÍµ≠, ÏïÑÏùºÎûúÎìú)Í∞Ä ÏûàÏñ¥. 
 
Ïù¥Í≤å Ï≤òÏùåÏóêÎäî ÎπÑÌà¨Ïî® Ïö©ÏúºÎ°ú Ï∂úÎ∞úÌñàÎã§Í∞Ä Î∞îÎÄêÍ±∞Ïïº.
 
ÏÇ¨Ïã§ÏÉÅ Ïù¥Í±¥ ÏßÄÏûêÏ≤¥Î≥¥Îã§ Ïä§Ìè¨Ï∏† Î¶¨Í∑∏ Ïö¥ÏòÅÏûêÎÇò Ïù¥Î≤§Ìä∏ ÌöåÏÇ¨ÏóêÏÑú Îçî ÎßéÏù¥ Î≥ºÌÖêÎç∞. ÏßÄÏûêÏ≤¥Îäî Í∑∏ÎÉ• Îî∞ÎùºÏò§Îäî Ïö©ÎèÑÎ°ú Ïç®ÏïºÌïòÍ≥† ÎÇ¥ Î©îÏù∏ ÌÉÄÏºìÏùÄ Ïù¥Îì§Ïù¥Ïïº. 
 
Ï∞∏Í≥†Î°ú, Ïï±ÏùÑ ÎßåÎì§ ÏÉùÍ∞ÅÏù¥ ÏóÜÏñ¥. ÎèàÏù¥ ÏïàÎêòÎãàÍπå ÌòÑÏû¨Îäî. 1ÏàúÏúÑ Î¶¨Í∑∏/Íµ¨Îã®, 2ÏàúÏúÑÎäî Ïù¥Î≤§Ìä∏ ÌöåÏÇ¨Ïïº 

Î†àÏù¥ÏïÑÏõÉÎ≥¥Î©¥ 

Dashboard
Schedules
Risk & Impact
Reports

Ïù¥ ÌÉ≠Îì§Ïù¥ ÏûàÏñ¥. ÏßÄÍ∏àÏùÄ ÎåÄÏãúÎ≥¥ÎìúÎ•º Ïñ¥ÎäêÏ†ïÎèÑ ÎßàÎ¨¥Î¶¨ÌïòÎ†§Í≥† Ìï¥


// src/app/ops/anchor/AnchorSetupSheet.tsx
"use client";

import { useEffect, useRef, useState } from "react";

export default function AnchorSetupSheet({
  areaLabel,
  onSubmit,
  onClose,
}: {
  areaLabel: string | null;
  onSubmit: (
    label: string,
    location: { lat: number; lng: number }
  ) => void;
  onClose: () => void;
}) {
  const inputRef = useRef<HTMLInputElement | null>(null);
  const autocompleteRef = useRef<google.maps.places.Autocomplete | null>(null);

  const handleClose = () => {
    onClose();
  };

  useEffect(() => {
    if (!inputRef.current) return;
    if (!window.google?.maps?.places) return;

    autocompleteRef.current =
      new google.maps.places.Autocomplete(inputRef.current, {
        fields: ["formatted_address", "geometry"],
      });

    autocompleteRef.current.addListener("place_changed", () => {
      const place = autocompleteRef.current!.getPlace();
      if (!place.geometry?.location) return;

      onSubmit(
        place.formatted_address || "Selected location",
        {
          lat: place.geometry.location.lat(),
          lng: place.geometry.location.lng(),
        }
      );

      onClose();
    });
  }, [onSubmit, onClose]);

  return (
    <div className="fixed inset-0 z-[9999] bg-background flex flex-col">
      <div className="flex items-center gap-2 p-4 border-b">
        <button
          onClick={handleClose}
          className="text-sm font-semibold"
        >
          ‚Üê Back
        </button>
        <span className="text-sm font-semibold">
          Search location
        </span>
      </div>

      <div className="p-4 flex-1">
        {areaLabel && (
          <p className="text-xs text-muted-foreground mb-2">
            {areaLabel}
          </p>
        )}

        <input
          ref={inputRef}
          type="text"
          placeholder="Search address, place, or city"
          className="
            w-full h-11
            rounded-xl
            bg-muted/40
            px-4
            text-sm
            outline-none
          "
          autoFocus
        />
        <p className="mt-2 text-xs text-muted-foreground">
          Select a place from the suggestions
        </p>
      </div>
    </div>
  );
}

// src/app/ops/anchor/detectAnchorCandidates.ts
import type { AreaIndex } from "@/types/area";

export function detectAnchorArea(
  pos: { lat: number; lng: number } | null,
  areas: AreaIndex[]
): string | null {
  if (!pos) return null;

  const nearby = areas.find(
    (a) =>
      a.center &&
      Math.abs(a.center.lat - pos.lat) < 0.5 &&
      Math.abs(a.center.lng - pos.lng) < 0.5
  );

  if (!nearby) return null;

  return nearby.city
    ? `${nearby.city} area detected`
    : nearby.region
    ? `${nearby.region} region detected`
    : null;
}

// src/app/ops/anchor/types.ts
export type AnchorLocation = {
  id: string;
  label: string;        // "Old Trafford"
  type: "venue" | "custom" | "city";
  lat: number;
  lng: number;
  source: "suggested" | "user";
};

//src/app/ops/components/home/DatePresetBar.tsx

"use client";

import { useMemo } from "react";

type Props = {
  activeDate: Date;
  onChange: (d: Date) => void;
  maxDays?: number;
  disabled?: boolean; // timeOpen Ï†ÑÎã¨Ïö©
};

/* =========================
   HELPERS
========================= */

function startOfDay(d: Date) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function isSameDay(a: Date, b: Date) {
  return (
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate()
  );
}

function nextSaturday(now: Date) {
  const d = startOfDay(now);
  d.setDate(d.getDate() + ((6 - d.getDay() + 7) % 7));
  return d;
}

function nextSunday(now: Date) {
  const d = startOfDay(now);
  d.setDate(d.getDate() + ((7 - d.getDay()) % 7));
  return d;
}

function toInputDate(d: Date) {
  return d.toISOString().slice(0, 10);
}

/* =========================
   COMPONENT
========================= */

export default function DatePresetBar({
  activeDate,
  onChange,
  maxDays,
  disabled,
}: Props) {
  const today = startOfDay(new Date());
  const sat = useMemo(() => nextSaturday(today), [today]);
  const sun = useMemo(() => nextSunday(today), [today]);

  const btn = (label: string, date: Date) => (
    <button
      key={label}
      type="button"
      onClick={() => onChange(date)}
      className={[
        "px-2 py-1 text-[11px] font-medium rounded-full transition",
        isSameDay(activeDate, date)
          ? "bg-transparent text-foreground"
          : "text-muted-foreground hover:text-foreground",
      ].join(" ")}
    >
      {label}
    </button>
  );

  return (
    <div className="inline-flex items-center gap-1">
      <div className="inline-flex items-center gap-1">
        {btn("Today", today)}
        {btn("Sat", sat)}
        {btn("Sun", sun)}
      </div>
      {/* üìÖ Calendar (iOS-safe) */}
      <div className="relative w-8 h-8 flex items-center justify-center">
        <span className="pointer-events-none">üìÖ</span>

        {/* üî• ÌïµÏã¨: Time Ïó¥Î†§ ÏûàÏúºÎ©¥ input ÏûêÏ≤¥Î•º DOMÏóêÏÑú Ï†úÍ±∞ */}
        {!disabled && (
          <input
            type="date"
            className="absolute inset-0 opacity-0 cursor-pointer"
            value={toInputDate(activeDate)}
            min={toInputDate(today)}
            max={
              maxDays
                ? toInputDate(
                    new Date(
                      today.getFullYear(),
                      today.getMonth(),
                      today.getDate() + maxDays
                    )
                  )
                : undefined
            }
            onChange={(e) => {
              if (!e.target.value) return;
              onChange(startOfDay(new Date(e.target.value)));
            }}
          />
        )}
      </div>
    </div>
  );
}


// src/app/ops/components/home/HomeMapStage.tsx
"use client";

import { forwardRef } from "react";
import type { Event } from "@/types";
import HomeEventMap, { HomeEventMapRef } from "@/app/ops/components/map-hero/HomeEventMap";

type Props = {
  events: Event[];
  onDiscoverFromMap: (eventId: string) => void;
  onBoundsChanged?: (bounds: google.maps.LatLngBoundsLiteral) => void;
};

const HomeMapStage = forwardRef<HomeEventMapRef, Props>(
  function HomeMapStage(
    { events, onDiscoverFromMap, onBoundsChanged }, // ‚úÖ Ïó¨Í∏∞!
    ref
  ) {
    return (
      <HomeEventMap
        ref={ref}
        events={events}
        onDiscover={onDiscoverFromMap}
        onBoundsChanged={onBoundsChanged}
      />
    );
  }
);

export default HomeMapStage;

// src/app/ops/components/home/LocationSheet.tsx
"use client";

import { useMemo, useState } from "react";

export default function LocationSheet({
  regions,
  cities,
  observerRegion,
  onPickRegion,
  onPickCity,
  onClose,
  onSetAnchor,              // üî• Ï∂îÍ∞Ä
}: {
  regions: { key: string; label: string }[]
  onPickRegion: (key: string | null) => void
  cities: string[];
  observerRegion: string | null;
  onPickCity: (c: string) => void;
  onClose: () => void;
  onSetAnchor: () => void;  // üî• Ï∂îÍ∞Ä
}) {

  const [query, setQuery] = useState("");

  const filteredCities = useMemo(() => {
    if (!query) return cities;
    return cities.filter((c) =>
      c.toLowerCase().includes(query.toLowerCase())
    );
  }, [cities, query]);

  return (
    <div className="fixed inset-0 z-50">
      {/* overlay */}
      <button
        className="absolute inset-0 bg-black/40"
        onClick={onClose}
        aria-label="Close"
      />

      {/* sheet */}
      <div
        className="
          absolute bottom-0 left-0 right-0
          bg-background
          rounded-t-2xl
          px-4 pt-3 pb-[env(safe-area-inset-bottom)]
          max-h-[70svh]
          overflow-y-auto
        "
      >
        {/* handle + close */}
        <div className="relative flex items-center justify-center mb-3">
          <div className="h-1.5 w-10 rounded-full bg-border/60" />
          <button
            onClick={onClose}
            className="absolute right-0 text-sm text-muted-foreground"
            aria-label="Close sheet"
          >
            ‚úï
          </button>
        </div>

        {/* title */}
        <p className="text-sm font-semibold mb-3">Event footprint</p>

        {/* REGION ‚Äì compact, progressive */}
        <div className="flex gap-2 overflow-x-auto pb-1 mb-4">
          <button
            onClick={() => onPickRegion(null)}
            className={[
              "shrink-0 px-3 py-1.5 rounded-full text-sm border",
              observerRegion === null
                ? "bg-black text-white border-black"
                : "border-border/60",
            ].join(" ")}
          >
              Portfolio-wide
            </button>

          {regions.map(({ key, label }) => {
            const active = key === observerRegion;

            return (
              <button
                key={key}
                onClick={() => onPickRegion(key)}   // üî• keyÎßå ÎÑòÍπÄ
                className={[
                  "shrink-0 px-3 py-1.5 rounded-full text-sm border",
                  active
                    ? "bg-black text-white border-black"
                    : "border-border/60",
                ].join(" ")}
              >
                {label}  {/* UI Ï†ÑÏö© */}
              </button>
            );
          })}

        </div>

        {/* CITY ‚Äì search first */}
        {observerRegion && (
          <div className="space-y-3">
            <input
              type="search"
              placeholder={`Search local footprint in ${observerRegion}`}
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              className="
                w-full h-11
                rounded-xl
                bg-muted/40
                px-4
                text-sm
                outline-none
              "
            />

            <div className="divide-y">
              {filteredCities.map((c) => (
                <button
                  key={c}
                  onClick={() => {
                    onPickCity(c);
                    onClose(); // ‚úÖ ÏÑ†ÌÉù Ï¶âÏãú Îã´Ìûò (2026 Ìå®ÌÑ¥)
                  }}
                  className="
                    w-full py-3
                    text-left text-sm
                    active:scale-[0.98]
                    transition
                  "
                >
                  {c}
                </button>
              ))}

              {filteredCities.length === 0 && (
                <p className="py-6 text-center text-sm text-muted-foreground">
                  No cities found
                </p>
              )}
            </div>
          </div>
        )}

        {/* OPERATIONAL BASE */}
        <div className="mt-6 pt-4 border-t">
          <button
            onClick={() => {
              onClose();      // LocationSheet Îã´Í≥†
              onSetAnchor();  // AnchorSetupSheet Ïó¥Í∏∞
            }}
            className="
              w-full h-11
              rounded-xl
              border
              text-sm font-semibold
              active:scale-[0.98]
              transition
            "
          >
            Set operational base
          </button>
        </div>
      </div>
    </div>
  );
}

//src/app/ops/components/home/useDistanceUnit.ts

"use client";

import { useEffect, useState } from "react";
import { detectDefaultUnit, DistanceUnit } from "@/lib/distance";

const STORAGE_KEY = "sportsive_distance_unit";

export function useDistanceUnit() {
  const [unit, setUnit] = useState<DistanceUnit>("km");

  useEffect(() => {
    const saved = localStorage.getItem(STORAGE_KEY) as DistanceUnit | null;
    if (saved === "km" || saved === "mi") {
      setUnit(saved);
    } else {
      setUnit(detectDefaultUnit());
    }
  }, []);

  const toggle = () => {
    setUnit((prev) => {
      const next = prev === "km" ? "mi" : "km";
      localStorage.setItem(STORAGE_KEY, next);
      return next;
    });
  };

  return { unit, toggle };
}


//src/app/ops/components/home/useLocationMode.ts

"use client";

import { useUserLocation } from "./useUserLocation";

export type LocationMode =
  | "observer"   // ÏúÑÏπò ÏóÜÏùå (Í∏∞Î≥∏)
  | "located";   // ÏúÑÏπò ÏûàÏùå

export function useLocationMode(): {
  mode: LocationMode;
  hasLocation: boolean;
} {
  const { pos } = useUserLocation();

  if (pos) {
    return { mode: "located", hasLocation: true };
  }

  return { mode: "observer", hasLocation: false };
}

// src/app/ops/components/home/useUserLocation.ts
"use client";

import { useEffect, useRef, useState } from "react";

export type LatLng = { lat: number; lng: number };

export function useUserLocation(options?: { enabled?: boolean }) {
  const [pos, setPos] = useState<LatLng | null>(null);
  const [denied, setDenied] = useState(false);
  const watchIdRef = useRef<number | null>(null);

  useEffect(() => {
    if (options?.enabled === false) return;
    if (!navigator.geolocation) {
      setDenied(true);
      return;
    }

    // 1Ô∏è‚É£ Ï¶âÏãú Ìïú Î≤à ÏöîÏ≤≠ (Îπ†Î•∏ Ï¥àÍ∏∞ Í∞í)
    navigator.geolocation.getCurrentPosition(
      (p) => {
        setPos({
          lat: p.coords.latitude,
          lng: p.coords.longitude,
        });
      },
      () => setDenied(true),
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 0,
      }
    );

    // 2Ô∏è‚É£ Ïù¥ÌõÑ Ï†ïÌôïÎèÑ Í∞úÏÑ†Ïö© watch
    watchIdRef.current = navigator.geolocation.watchPosition(
      (p) => {
        setPos({
          lat: p.coords.latitude,
          lng: p.coords.longitude,
        });
      },
      () => setDenied(true),
      {
        enableHighAccuracy: true,
        maximumAge: 0,
      }
    );

    // cleanup
    return () => {
      if (watchIdRef.current != null) {
        navigator.geolocation.clearWatch(watchIdRef.current);
        watchIdRef.current = null;
      }
    };
  }, [options?.enabled]);

  return { pos, denied };
}

export function haversineKm(a: LatLng, b: LatLng) {
  const toRad = (x: number) => (x * Math.PI) / 180;
  const R = 6371;

  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);

  const s1 =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(a.lat)) *
      Math.cos(toRad(b.lat)) *
      Math.sin(dLng / 2) *
      Math.sin(dLng / 2);

  const c = 2 * Math.atan2(Math.sqrt(s1), Math.sqrt(1 - s1));
  return R * c;
}

//src/lib/infra/attentionLevel.ts

import type { PeakScope } from "@/types/infra";

export type AttentionLevel = "low" | "medium" | "high";

export function getAttentionLevel(
  count: number,
  scope: PeakScope
): AttentionLevel {
  const isCity = scope.type === "city";

  if (isCity) {
    if (count <= 2) return "low";
    if (count <= 4) return "medium";
    return "high";
  }

  // region or all
  if (count <= 4) return "low";
  if (count <= 7) return "medium";
  return "high";
}

//src/lib/impact/presets.ts

import { ImpactProfile } from "./types";

export const SPORT_IMPACT_PRESETS: Record<string, ImpactProfile> = {
  football: {
    type: "fixed",
    phases: [
      // Í≤ΩÍ∏∞ ÏãúÏûë Ï†Ñ Ïú†ÏûÖ
      { offset: -90, duration: 60, weight: 1.0 },
      // Í≤ΩÍ∏∞ Ï¢ÖÎ£å Ï†Ñ/ÌõÑ Ïù¥ÌÉà
      { offset: 85, duration: 50, weight: 0.8 },
    ],
    confidence: "high",
  },

  rugby: {
    type: "fixed",
    phases: [
      { offset: -90, duration: 60, weight: 1.0 },
      { offset: 90, duration: 55, weight: 0.8 },
    ],
    confidence: "high",
  },

  basketball: {
    type: "fixed",
    phases: [
      { offset: -50, duration: 40, weight: 0.9 },
      { offset: 65, duration: 35, weight: 0.7 },
    ],
    confidence: "medium",
  },

  tennis: {
    type: "session",
    phases: [
      // ÌïòÎ£® Ï¢ÖÏùº Ï°∞Í∏àÏî© Ïú†ÏûÖ/Ïú†Ï∂ú
      { offset: -180, duration: 360, weight: 0.3 },
    ],
    confidence: "low",
  },

  darts: {
    type: "session",
    phases: [
      { offset: -120, duration: 240, weight: 0.35 },
    ],
    confidence: "low",
  },

  horse_racing: {
    type: "block",
    window: {
      startHour: 11,
      endHour: 17,
    },
    confidence: "medium",
  },
};

// src/app/api/events/route.ts

import { NextResponse } from "next/server";
import { GET as getFootballEvents } from "./england/football/route";
import { GET as getRugbyEvents } from "./england/rugby/route";
import { GET as getTennisEvents } from "./england/tennis/route";
import { GET as getHorseRacingEvents } from "./england/horseRacing/route";
import { GET as getBasketballEvents } from "./england/basketball/route";
import { GET as getDartEvents } from "./england/dart/route";

import { isEventActiveInWindow } from "@/lib/events/lifecycle";
import { buildAreaIndex } from "@/lib/events/buildAreaIndex";

/* =========================
   üîß DEDUPE HELPER (ÌïµÏã¨)
========================= */
function dedupeById(events: any[]) {
  return Array.from(
    new Map(events.map((e) => [e.id, e])).values()
  );
}

export async function GET(req: Request) {
  try {
    const url = new URL(req.url);
    const window = url.searchParams.get("window") ?? "7d";

    const [
      footballRes,
      rugbyRes,
      tennisRes,
      horseRacingRes,
      basketballRes,
      dartRes,
    ] = await Promise.all([
      getFootballEvents(),
      getRugbyEvents(),
      getTennisEvents(),
      getHorseRacingEvents(),
      getBasketballEvents(),
      getDartEvents(),
    ]);

    const footballData = await footballRes.json();
    const rugbyData = await rugbyRes.json();
    const tennisData = await tennisRes.json();
    const horseRacingData = await horseRacingRes.json();
    const basketballData = await basketballRes.json();
    const dartData = await dartRes.json();

    /* =========================
       1Ô∏è‚É£ RAW MERGE (Ï§ëÎ≥µ ÌóàÏö©)
    ========================= */
    const mergedRaw = [
      ...(footballData.matches ?? footballData.events ?? []),
      ...(rugbyData.matches ?? rugbyData.events ?? []),
      ...(tennisData.matches ?? tennisData.events ?? []),
      ...(horseRacingData.matches ?? horseRacingData.events ?? []),
      ...(basketballData.events ?? []),
      ...(dartData.matches ?? dartData.events ?? []),
    ];

    /* =========================
       2Ô∏è‚É£ üî• DEDUPE BY EVENT ID
    ========================= */
    const merged = dedupeById(mergedRaw);

    /* =========================
       3Ô∏è‚É£ AREA INDEX (ÏßÄÎèÑ Íµ¨Ï°∞)
    ========================= */
    if (window === "180d") {
      const areas = buildAreaIndex(merged);
      return NextResponse.json({ areas });
    }

    /* =========================
       4Ô∏è‚É£ TIME WINDOW FILTER
    ========================= */
    const now = new Date();
    const windowEnd = new Date(now);

    if (window === "today") {
      windowEnd.setHours(23, 59, 59, 999);
    } else if (window === "7d") {
      windowEnd.setDate(windowEnd.getDate() + 7);
    } else if (window === "30d") {
      windowEnd.setDate(windowEnd.getDate() + 30);
    } else if (window === "60d") {
      windowEnd.setDate(windowEnd.getDate() + 60);
    } else if (window === "180d") {
      windowEnd.setDate(windowEnd.getDate() + 180);
    }

    const filtered = merged
      .filter((e: any) => isEventActiveInWindow(e, now, windowEnd))
      .map((e: any) => ({
        ...e,
        startAtUtc: e.date, // sorting & discovery Í∏∞Ï§Ä
      }))
      .sort(
        (a: any, b: any) =>
          new Date(a.startAtUtc).getTime() -
          new Date(b.startAtUtc).getTime()
      );

    return NextResponse.json({ events: filtered });
  } catch (error) {
    console.error("‚ùå Error combining event APIs:", error);
    return NextResponse.json({ events: [] }, { status: 500 });
  }
}

