내 플랫폼은 이거야. 근데 내가 지금 돈이 안보여... 이게 문제야...내 불편한 점으로 만들기 시작했는데, 지도 기반으로만 하면 사람들이 머무르지 않고, 투자도 못받을 것 같아서, 계정만들기, 피드, 채팅, 밋업, 팀페이지 기능을 넣었었어. 근데 이게 결국 산으로 가더라고. 그냥 스포츠 커뮤니티? 그래서 완전히 줄이고 줄여서 지도기반으로만 둔거야. 그래서 이걸로 투자를 받을 방법이 없을까 싶은거지. 투자를 받아야 영국에 창업비자나 글로벌 탤런트 비자를 신청할텐데...투자가 안보이지? 

사실은 티켓 링크 기능도 없었어. 근데 이거라도 넣으면 커미션 방향이라도 생기지 않을까하는 생각에 넣은거야. 내가 티켓 url을 찾다보니 느낀건 모든 티켓은 각자의 구단 홈피에서만 살수 있다는거야. 그래서 의도를 가지고 홈페이지에 들어가지 않는 이상 스포츠를 접하기 힘든거야. 일단 슈파베이스에 각 링크 다 넣었어. 그리고 목표를 약간 수정했는데, 나가기전 행동 직전의 플랫폼이 아니라 심심할 때 '주변에 무슨 경기가 열리나....'를 열어볼 수 있는? 

그런 플랫폼을 만들고 싶어 참고로 지금 당장 거약 투자? 이런거 안바라. 소액 엔젤 투자자라도 얻고 싶어. 사람들이 심심할때 그냥 한번 열어보고 닫을 무언가가 없을까. 내가 나가기전에 열어보는 웹으로 목적을 두니까 이게 너무 돈이 안보여서

참고로 서프라이즈 미 이런 기능이랑 'there is quite around you' 이런 기능들 넣었었는데 내 제품이랑 안맞아

슈파베이스에 티켓 클릭 순간 테이블에 찍히라고 연결도 해놨어.

사람들이 심심할때 여러번 들어오게 하는 방법이 없으려나?

// src/lib/analytics.ts

export type EventName =
  | "home_loaded"
  | "surprise_clicked"
  | "match_discovered"
  | "daily_discovery_completed"
  | "map_opened"
  | "map_closed"
  | "stamp_earned"
  | "details_opened"
  | "live_opened";

export type EventProps = Record<string, string>;

/**
 * 개발자(본인) 여부
 * - 로컬 / dev 환경: 자동 true
 * - 배포 환경: NEXT_PUBLIC_IS_DEV=true 인 브라우저만 true
 */
const isDevUser =
  process.env.NODE_ENV !== "production" ||
  process.env.NEXT_PUBLIC_IS_DEV === "true";

export function logEvent(
  name: EventName | string,
  props?: EventProps
) {
  const finalProps: EventProps = {
    ...(props ?? {}),
    ...(isDevUser ? { is_dev: "true" } : {}),
  };

  if (process.env.NODE_ENV !== "production") {
    if (Object.keys(finalProps).length > 0) {
      console.log(`[analytics] ${name}`, finalProps);
    } else {
      console.log(`[analytics] ${name}`);
    }
  }

  // 미래:
  // GA4:
  // logEvent(analytics, name, finalProps)

  // PostHog:
  // posthog.capture(name, finalProps)
}

// src/lib/eventTime.ts

export type EventTimeState =
  | "LIVE"
  | "SOON"
  | "UPCOMING"
  | "ENDED";

export function getDefaultDurationMs(e: {
  durationMs?: number;
  sport?: string;
}): number {
  if (e.durationMs) return e.durationMs;

  switch (e.sport) {
    case "football":
    case "rugby":
      return 2.5 * 60 * 60 * 1000;
    case "basketball":
      return 2 * 60 * 60 * 1000;
    case "tennis":
      return 3 * 60 * 60 * 1000;
    case "horse-racing":
      return 6 * 60 * 60 * 1000;
    default:
      return 2 * 60 * 60 * 1000;
  }
}

export function getSoonWindowMs(e: {
  soonWindowMs?: number;
  sport?: string;
}): number {
  if (e.soonWindowMs) return e.soonWindowMs;

  switch (e.sport) {
    case "tennis":
      return 60 * 60 * 1000;
    case "basketball":
      return 90 * 60 * 1000;
    case "horse-racing":
      return 4 * 60 * 60 * 1000;
    default:
      return 2 * 60 * 60 * 1000;
  }
}

export function getEventTimeState(
  e: {
    startDate?: string | Date;
    date?: string | Date;
    utcDate?: string | Date;
    durationMs?: number;
    soonWindowMs?: number;
    sport?: string;
  },
  now: Date = new Date()
): EventTimeState {
  const raw = e.startDate ?? e.date ?? e.utcDate;
  const start = new Date(raw as any);

  if (isNaN(start.getTime())) return "ENDED";

  const end = new Date(start.getTime() + getDefaultDurationMs(e));
  const diffMs = start.getTime() - now.getTime();

  if (now >= start && now <= end) return "LIVE";
  if (diffMs > 0 && diffMs <= getSoonWindowMs(e)) return "SOON";
  if (diffMs > 0) return "UPCOMING";

  return "ENDED";
}

// src/lib/nowDashboard.ts
import type { Event } from "@/types";

/**
 * ✅ MVP용으로 NowHero를 "checking tool"에 맞게 최소화한 상태 계산기
 * - TimeScope별 "LIVE 있냐 / NEXT가 언제냐 / 없냐"만 만든다
 * - peak, sportCounts, dayCount 등은 제거 (지금 UI에서 안 씀)
 */

export type TimeScope = "today" | "tomorrow" | "weekend" | "week";

export type NowStatus = {
  scope: TimeScope;
  kind: "live" | "next" | "empty";
  liveCount: number;
  nextAt: Date | null;
  count: number; // scope 안의 전체 이벤트 수 (UI에서 안 쓰면 그냥 둬도 됨)
  text: string;  // NowHero 메인 1줄
};

function getStartDate(e: any): Date | null {
  const raw = e.date ?? e.utcDate ?? e.startDate ?? null;
  if (!raw) return null;
  const d = new Date(raw);
  return isNaN(d.getTime()) ? null : d;
}

function startOfLocalDay(d: Date) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function isSameLocalDay(a: Date, b: Date) {
  return (
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate()
  );
}

function nextWeekendRange(now: Date) {
  const base = startOfLocalDay(now);
  const day = base.getDay(); // 0 Sun ... 6 Sat
  const toSat = day === 6 ? 0 : (6 - day + 7) % 7;
  const sat = new Date(base);
  sat.setDate(sat.getDate() + toSat);

  const mon = new Date(sat);
  mon.setDate(mon.getDate() + 2); // exclusive
  return { start: sat, end: mon };
}

function formatTime(dt: Date) {
  return dt.toLocaleTimeString(undefined, { hour: "numeric", minute: "2-digit" });
}

function inScope(start: Date, scope: TimeScope, now: Date) {
  const base = startOfLocalDay(now);

  if (scope === "today") {
    // "지금 나갈까" 체크이므로 과거 시작은 제외 (토너먼트 예외는 events 필터에서 이미 처리하는 게 더 안전)
    return isSameLocalDay(start, now) && start >= now;
  }

  if (scope === "tomorrow") {
    const t0 = new Date(base);
    t0.setDate(t0.getDate() + 1);
    const t1 = new Date(t0);
    t1.setDate(t1.getDate() + 1);
    return start >= t0 && start < t1;
  }

  if (scope === "weekend") {
    const wk = nextWeekendRange(now);
    return start >= wk.start && start < wk.end;
  }

  // week: next 7 days from start of today
  const end = new Date(base);
  end.setDate(end.getDate() + 7);
  return start >= now && start < end;
}

export function buildNowStatus(
  events: Event[],
  scope: TimeScope,
  now = new Date()
): NowStatus {
  let liveCount = 0;
  let nextAt: Date | null = null;
  let count = 0;

  for (const e of events as any[]) {
    const start = getStartDate(e);
    if (!start) continue;
    if (!inScope(start, scope, now)) continue;

    count += 1;

    const status = (e.status ?? "").toString().toUpperCase();
    if (status === "LIVE") liveCount += 1;

    if (start > now) {
      if (!nextAt || start < nextAt) nextAt = start;
    }
  }

  if (liveCount > 0) {
    return {
      scope,
      kind: "live",
      liveCount,
      nextAt,
      count,
      text: `${liveCount} LIVE`,
    };
  }

  if (nextAt) {
    return {
      scope,
      kind: "next",
      liveCount,
      nextAt,
      count,
      text: `NEXT ${formatTime(nextAt)}`,
    };
  }

  const label =
    scope === "today"
      ? "TODAY"
      : scope === "tomorrow"
      ? "TOMORROW"
      : scope === "weekend"
      ? "THIS WEEKEND"
      : "THIS WEEK";

  return {
    scope,
    kind: "empty",
    liveCount,
    nextAt: null,
    count,
    text: `NO EVENTS ${label}`,
  };
}

"use client";

import Link from "next/link";

export default function LandingPage() {
  return (
    <main className="min-h-screen bg-background text-foreground flex flex-col">
      {/* =========================
          HERO
      ========================= */}
      <section className="min-h-[70vh] flex flex-col items-center justify-center text-center px-6">
        <div className="mb-6 select-none">
          <span className="font-extrabold text-[3.2rem] leading-none">
            sp
            <span className="inline-block bg-gradient-to-r from-red-500 via-yellow-400 via-green-500 to-blue-500 text-transparent bg-clip-text">
              o
            </span>
            rtsive
          </span>
        </div>

        <p className="text-lg text-muted-foreground max-w-md">
          Check what sports are happening near you, right now.
        </p>

        <p className="text-xs text-muted-foreground mt-6 max-w-md">
          Built to understand how people discover live sports around them — before they plan anything.
        </p>

      </section>

      {/* =========================
          WHAT IT IS / IS NOT
      ========================= */}
      <section className="px-6 py-20 max-w-2xl mx-auto space-y-14">
        <div>
          <p className="text-xs font-semibold tracking-widest text-muted-foreground">
            NOT A FAN PLATFORM
          </p>
          <p className="mt-3 text-xl font-medium">
            You don’t need to follow teams, leagues, or schedules.
          </p>
        </div>

        <div>
          <p className="text-xs font-semibold tracking-widest text-muted-foreground">
            JUST A CHECK
          </p>
          <p className="mt-3 text-xl font-medium">
            Open Sportsive anytime to see what’s actually happening nearby.
          </p>
        </div>

        <div>
          <p className="text-xs font-semibold tracking-widest text-muted-foreground">
            LOCATION & TIME FIRST
          </p>
          <p className="mt-3 text-xl font-medium">
            Every event is shown by where and when it’s happening — nothing else.
          </p>
        </div>
      </section>

      {/* =========================
          CTA
      ========================= */}
      <section className="px-6 pb-16 max-w-xl mx-auto w-full">
        <Link
          href="/app"
          className="
            block w-full
            text-center
            rounded-2xl
            bg-black text-white
            py-4
            text-sm font-semibold
            hover:opacity-90
            transition
          "
        >
          Open full-screen map
        </Link>

      </section>

      {/* =========================
          HELP SHAPE SPORTSIVE (FOOTER)
      ========================= */}
      <section
        className="
          max-w-xl mx-auto
          text-center
          text-xs
          text-muted-foreground
          space-y-4
          pt-8
          pb-10
          border-t border-border/60
          px-6
        "
      >
        <p className="font-medium text-foreground">
          This is an early experiment.
        </p>
        <p className="text-[11px] opacity-70">
          Built and maintained by a single creator as a live product experiment.
        </p>


        <p className="leading-relaxed">
          If there’s a match or event you think should be here,
          or if something feels missing, I’d love to hear from you.
        </p>

        <div className="flex justify-center gap-4">
          <a
            href="https://www.instagram.com/sportsive_/"
            target="_blank"
            rel="noopener noreferrer"
            className="underline underline-offset-4"
          >
            Instagram
          </a>
          <a
            href="https://www.linkedin.com/in/kim-eg/"
            target="_blank"
            rel="noopener noreferrer"
            className="underline underline-offset-4"
          >
            LinkedIn
          </a>
        </div>

        <p className="opacity-70">
          I read every message.
        </p>
      </section>
    </main>
  );
}
// src/app/components/home/HomeMapStage.tsx
"use client";

import { forwardRef } from "react";
import type { Event } from "@/types";
import type { TimeScope } from "@/lib/nowDashboard";
import HomeEventMap, { HomeEventMapRef } from "@/app/components/map-hero/HomeEventMap";

type Props = {
  events: Event[];
  timeScope: TimeScope;
  onDiscoverFromMap: (eventId: string) => void;
  onBoundsChanged?: (bounds: google.maps.LatLngBoundsLiteral) => void;
};

const HomeMapStage = forwardRef<HomeEventMapRef, Props>(
  function HomeMapStage(
    { events, timeScope, onDiscoverFromMap, onBoundsChanged }, // ✅ 여기!
    ref
  ) {
    return (
      <HomeEventMap
        ref={ref}
        events={events}
        timeScope={timeScope}          // ✅ 정상
        onDiscover={onDiscoverFromMap}
        onBoundsChanged={onBoundsChanged}
      />
    );
  }
);

export default HomeMapStage;

// src/app/components/home/LocationSheet.tsx
"use client";

import { useMemo, useState } from "react";

export default function LocationSheet({
  regions,
  cities,
  observerRegion,
  onPickRegion,
  onPickCity,
  onClose,
}: {
  regions: string[];
  cities: string[];
  observerRegion: string | null;
  onPickRegion: (r: string | null) => void;
  onPickCity: (c: string) => void;
  onClose: () => void;
}) {
  const [query, setQuery] = useState("");

  const filteredCities = useMemo(() => {
    if (!query) return cities;
    return cities.filter((c) =>
      c.toLowerCase().includes(query.toLowerCase())
    );
  }, [cities, query]);

  return (
    <div className="fixed inset-0 z-50">
      {/* overlay */}
      <button
        className="absolute inset-0 bg-black/40"
        onClick={onClose}
        aria-label="Close"
      />

      {/* sheet */}
      <div
        className="
          absolute bottom-0 left-0 right-0
          bg-background
          rounded-t-2xl
          px-4 pt-3 pb-[env(safe-area-inset-bottom)]
          max-h-[70svh]
          overflow-y-auto
        "
      >
        {/* handle + close */}
        <div className="relative flex items-center justify-center mb-3">
          <div className="h-1.5 w-10 rounded-full bg-border/60" />
          <button
            onClick={onClose}
            className="absolute right-0 text-sm text-muted-foreground"
            aria-label="Close sheet"
          >
            ✕
          </button>
        </div>

        {/* title */}
        <p className="text-sm font-semibold mb-3">Location</p>

        {/* REGION – compact, progressive */}
        <div className="flex gap-2 overflow-x-auto pb-1 mb-4">
          <button
            onClick={() => onPickRegion(null)}
            className={[
              "shrink-0 px-3 py-1.5 rounded-full text-sm border",
              observerRegion === null
                ? "bg-black text-white border-black"
                : "border-border/60",
            ].join(" ")}
          >
            All
          </button>

          {regions.slice(0, 6).map((r) => {
            const active = r === observerRegion;
            return (
              <button
                key={r}
                onClick={() => onPickRegion(r)}
                className={[
                  "shrink-0 px-3 py-1.5 rounded-full text-sm border",
                  active
                    ? "bg-black text-white border-black"
                    : "border-border/60",
                ].join(" ")}
              >
                {r}
              </button>
            );
          })}
        </div>

        {/* CITY – search first */}
        {observerRegion && (
          <div className="space-y-3">
            <input
              type="search"
              placeholder={`Search city in ${observerRegion}`}
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              className="
                w-full h-11
                rounded-xl
                bg-muted/40
                px-4
                text-sm
                outline-none
              "
            />

            <div className="divide-y">
              {filteredCities.map((c) => (
                <button
                  key={c}
                  onClick={() => {
                    onPickCity(c);
                    onClose(); // ✅ 선택 즉시 닫힘 (2026 패턴)
                  }}
                  className="
                    w-full py-3
                    text-left text-sm
                    active:scale-[0.98]
                    transition
                  "
                >
                  {c}
                </button>
              ))}

              {filteredCities.length === 0 && (
                <p className="py-6 text-center text-sm text-muted-foreground">
                  No cities found
                </p>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

//src/app/components/home/MapStatusPill.tsx

"use client";

import type { Event } from "@/types";

function getStartDate(e: any): Date | null {
  const raw = e.date ?? e.utcDate ?? e.startDate ?? null;
  if (!raw) return null;
  const d = new Date(raw);
  return isNaN(d.getTime()) ? null : d;
}

export default function MapStatusPill({ events }: { events: Event[] }) {
  const now = Date.now();

  let live = 0;
  let nextAt: Date | null = null;

  for (const e of events as any[]) {
    const status = (e.status ?? "").toUpperCase();
    if (status === "LIVE") live += 1;

    const start = getStartDate(e);
    if (start && start.getTime() > now) {
      if (!nextAt || start < nextAt) nextAt = start;
    }
  }

  const total = events.length;

  // 아무것도 없으면 조용히
  if (total === 0) return null;

  let label: string;

  if (live > 0) {
    // 예: "2 LIVE · 6 TODAY"
    label = `${live} LIVE · ${total} TODAY`;
  } else if (nextAt) {
    // 예: "6 TODAY · NEXT 19:30"
    const t = nextAt.toLocaleTimeString(undefined, {
      hour: "numeric",
      minute: "2-digit",
    });
    label = `${total} TODAY · NEXT ${t}`;
  } else {
    // 이론상 거의 안 옴 (오늘 이벤트인데 시작 시간이 다 지남)
    return null;
  }

  return (
    <div
      className="
        pointer-events-none
        fixed
        left-1/2 -translate-x-1/2
        bottom-[calc(env(safe-area-inset-bottom)+96px)]
        z-50
      "
    >
      <div
        className="
          rounded-full
          bg-black/85
          text-white
          text-xs
          font-semibold
          px-4
          py-2
          shadow-lg
          tracking-wide
          whitespace-nowrap
        "
      >
        {label}
      </div>
    </div>
  );
}

// src/app/components/home/NowHeroScopeBar.tsx

"use client";

import type { TimeScope } from "@/lib/nowDashboard";

export default function NowHeroScopeBar({
  scope,
  onScopeChange,
}: {
  scope: TimeScope;
  onScopeChange: (s: TimeScope) => void;
}) {
  return (
    <div
      className="
        inline-flex items-center
        rounded-full
        bg-background/60
        ring-1 ring-border/40
        p-1
      "
    >
      {(["today", "tomorrow", "weekend", "week"] as TimeScope[]).map((s) => (
        <button
          key={s}
          onClick={() => onScopeChange(s)}
          className={[
            "px-2.5 py-1.5 text-[12px] font-semibold rounded-full transition",
            scope === s
              ? "bg-foreground text-background shadow-sm"
              : "text-muted-foreground",
          ].join(" ")}
        >
          {s === "today" ? "Today" :
           s === "tomorrow" ? "Tomorrow" :
           s === "weekend" ? "Weekend" : "Week"}
        </button>
      ))}
    </div>
  );
}

//src/app/components/home/useDistanceUnit.ts

"use client";

import { useEffect, useState } from "react";
import { detectDefaultUnit, DistanceUnit } from "@/lib/distance";

const STORAGE_KEY = "sportsive_distance_unit";

export function useDistanceUnit() {
  const [unit, setUnit] = useState<DistanceUnit>("km");

  useEffect(() => {
    const saved = localStorage.getItem(STORAGE_KEY) as DistanceUnit | null;
    if (saved === "km" || saved === "mi") {
      setUnit(saved);
    } else {
      setUnit(detectDefaultUnit());
    }
  }, []);

  const toggle = () => {
    setUnit((prev) => {
      const next = prev === "km" ? "mi" : "km";
      localStorage.setItem(STORAGE_KEY, next);
      return next;
    });
  };

  return { unit, toggle };
}

//src/app/components/home/useLocationMode.ts

"use client";

import { useUserLocation } from "./useUserLocation";

export type LocationMode =
  | "observer"   // 위치 없음 (기본)
  | "located";   // 위치 있음

export function useLocationMode(): {
  mode: LocationMode;
  hasLocation: boolean;
} {
  const { pos } = useUserLocation();

  if (pos) {
    return { mode: "located", hasLocation: true };
  }

  return { mode: "observer", hasLocation: false };
}

//src/app/components/home/useUserLocation.ts

"use client";

import { useEffect, useState } from "react";

export type LatLng = { lat: number; lng: number };

export function useUserLocation(options?: { enabled?: boolean }) {
  const [pos, setPos] = useState<LatLng | null>(null);
  const [denied, setDenied] = useState(false);

  useEffect(() => {
    if (options?.enabled === false) return;
    if (!navigator.geolocation) return;

    navigator.geolocation.getCurrentPosition(
      (p) => {
        setPos({ lat: p.coords.latitude, lng: p.coords.longitude });
      },
      () => setDenied(true),
      { enableHighAccuracy: false, timeout: 7000 }
    );
  }, [options?.enabled]);

  return { pos, denied };
}

export function haversineKm(a: LatLng, b: LatLng) {
  const toRad = (x: number) => (x * Math.PI) / 180;
  const R = 6371;

  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);

  const s1 =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);

  const c = 2 * Math.atan2(Math.sqrt(s1), Math.sqrt(1 - s1));
  return R * c;
}

// src/app/api/go/ticket/route.ts
import { NextRequest, NextResponse } from "next/server";
import { supabase } from "../../../../lib/supabaseServer";

/**
 * Ticket click = high-intent action
 * This log is the KPI source of truth for investor conversations.
 */
type TicketClickLog = {
  type: "ticket_click";
  ts: string;
  eventId: string;
  sport: string | null;
  city: string | null;

  // where the click happened
  source: "snap_card" | "map" | "list" | "unknown";

  userAgent: string | null;
  ip: string | null;
  referrer: string | null;
};

async function logTicketClick(log: TicketClickLog) {
  await supabase.from("ticket_clicks").insert({
    event_id: log.eventId,
    sport: log.sport,
    city: log.city,
    source: log.source,
  });
}

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);

  const eventId = searchParams.get("eventId");
  const target = searchParams.get("target");

  if (!eventId || !target) {
    return NextResponse.json({ error: "Bad request" }, { status: 400 });
  }

  // ✅ Validate target URL (security & data integrity)
  try {
    new URL(target);
  } catch {
    return NextResponse.json({ error: "Invalid target" }, { status: 400 });
  }

  // ✅ Click source (default: unknown)
  const sourceParam = searchParams.get("source");
  const source: TicketClickLog["source"] =
    sourceParam === "snap_card" ||
    sourceParam === "map" ||
    sourceParam === "list"
      ? sourceParam
      : "unknown";

  // ✅ Client IP extraction (proxy / Vercel safe)
  const forwardedFor = req.headers.get("x-forwarded-for");
  const ip = forwardedFor
    ? forwardedFor.split(",")[0].trim()
    : null;

  await logTicketClick({
    type: "ticket_click",
    ts: new Date().toISOString(),
    eventId,
    sport: searchParams.get("sport"),
    city: searchParams.get("city"),
    source,
    userAgent: req.headers.get("user-agent"),
    ip,
    referrer: req.headers.get("referer"),
  });

  // ✅ Redirect after logging
  return NextResponse.redirect(target, { status: 302 });
}


