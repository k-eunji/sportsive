ë‚´ í”Œë«í¼ì€ ì´ê±°ì•¼. ì°¸ê³ ë¡œ epl, ì±”í”¼ì–¸ì‰¼, efl 1, efl 2, ì˜êµ­ì—ì„œ ì—´ë¦¬ëŠ” ë‹¤íŠ¸ë‘ í…Œë‹ˆìŠ¤, ê²½ë§ˆ(ì•„ì¼ëœë“œ í¬í•¨), ë†êµ¬, í”„ë¦¬ë¯¸ì–´ì‰½ ëŸ­ë¹„ ë°ì´í„°ê°€ ìˆì–´ ëª©ì ì„ ì•½ê°„ ë°”ê¿¨ì–´. ì²˜ìŒì—ëŠ” ê·¸ëƒ¥ ì‚¬ëŒë“¤ì´ 'ì˜¤ëŠ˜ ì—¬ê¸°ì„œ ë­í•˜ëŠ”ì§€ ê¶ê¸ˆí•œë° ë­ ë³¼ê²Œ ì—†ë‚˜'ë¼ëŠ” ìƒê°ìœ¼ë¡œ ì ‘ê·¼í•˜ê²Œ ë§Œë“¤ì—ˆì—ˆë‹¤?  


ì²˜ìŒì—ëŠ” ì§€ë„ ê¸°ë°˜ìœ¼ë¡œë§Œ í•˜ë©´ ì‚¬ëŒë“¤ì´ ë¨¸ë¬´ë¥´ì§€ ì•Šê³ , íˆ¬ìë„ ëª»ë°›ì„ ê²ƒ ê°™ì•„ì„œ, ê³„ì •ë§Œë“¤ê¸°, í”¼ë“œ, ì±„íŒ…, ë°‹ì—…, íŒ€í˜ì´ì§€ ê¸°ëŠ¥ì„ ë„£ì—ˆì—ˆì–´. ê·¼ë° ì´ê²Œ ê²°êµ­ ì‚°ìœ¼ë¡œ ê°€ë”ë¼ê³ . ê·¸ëƒ¥ ìŠ¤í¬ì¸  ì»¤ë®¤ë‹ˆí‹°? ê·¸ë˜ì„œ ì™„ì „íˆ ì¤„ì´ê³  ì¤„ì—¬ì„œ ì§€ë„ê¸°ë°˜ìœ¼ë¡œë§Œ ë‘”ê±°ì•¼.  


ì‚¬ì‹¤ì€ í‹°ì¼“ ë§í¬ ê¸°ëŠ¥ë„ ì—†ì—ˆì–´. ê·¼ë° ì´ê±°ë¼ë„ ë„£ìœ¼ë©´ ì»¤ë¯¸ì…˜ ë°©í–¥ì´ë¼ë„ ìƒê¸°ì§€ ì•Šì„ê¹Œí•˜ëŠ” ìƒê°ì— ë„£ì€ê±°ì•¼. ë‚´ê°€ í‹°ì¼“ urlì„ ì°¾ë‹¤ë³´ë‹ˆ ëŠë‚€ê±´ ëª¨ë“  í‹°ì¼“ì€ ê°ìì˜ êµ¬ë‹¨ í™ˆí”¼ì—ì„œë§Œ ì‚´ìˆ˜ ìˆë‹¤ëŠ”ê±°ì•¼. ê·¸ë˜ì„œ ì˜ë„ë¥¼ ê°€ì§€ê³  í™ˆí˜ì´ì§€ì— ë“¤ì–´ê°€ì§€ ì•ŠëŠ” ì´ìƒ ìŠ¤í¬ì¸ ë¥¼ ì ‘í•˜ê¸° í˜ë“ ê±°ì•¼. ì¼ë‹¨ ìŠˆíŒŒë² ì´ìŠ¤ì— ê° ë§í¬ ë‹¤ ë„£ì—ˆì–´. ê·¸ë¦¬ê³  ëª©í‘œë¥¼ ì•½ê°„ ìˆ˜ì •í–ˆëŠ”ë°, ë‚˜ê°€ê¸°ì „ í–‰ë™ ì§ì „ì˜ í”Œë«í¼ì´ ì•„ë‹ˆë¼ ì‹¬ì‹¬í•  ë•Œ 'ì£¼ë³€ì— ë¬´ìŠ¨ ê²½ê¸°ê°€ ì—´ë¦¬ë‚˜....'ë¥¼ ì—´ì–´ë³¼ ìˆ˜ ìˆëŠ”? 


ê·¼ë° ì´ëŸ°ì‹ìœ¼ë¡œ ê°€ë‹¤ê°„ ë°©ë¬¸ìë„ ì—†ì„ ê²ƒ ê°™ì•„ì„œ ê²°êµ­ ì•½ê°„ ëª©ì ì„ ìˆ˜ì •í–ˆì–´. ì²˜ìŒì—ëŠ” 'ì˜¤ëŠ˜ ë­ìˆì§€' ë¼ëŠ” ëª©ì ìœ¼ë¡œ ë‹¤ê°€ì˜¤ê²Œ í–ˆì—ˆëŠ”ë°, ì´ í”Œë«í¼ì€ ì‚¬ëŒì´ ì—†ì„ ê²ƒ ê°™ì•„ì„œ ë‚ ì§œ, ì‹œê°„ ê¸°ë°˜ì´ ì•„ë‹Œ ê·¸ëƒ¥ íŒ€ ê¸°ë°˜ìœ¼ë¡œ ë°”ê¾¸ê²Œ ëœê±°ì•¼. ê·¸ëŸ¬ë©´ì„œ ë¦¬ìŠ¤íŠ¸ë„ songKick í˜•ì‹ì„ ì°¨ìš©í•˜ê²Œ ëì–´.
 

SportsiveëŠ” ê²°ê³¼ì ìœ¼ë¡œ **ë‹¨ì¼ íƒ€ê¹ƒ ì„œë¹„ìŠ¤ê°€ ì•„ë‹ˆë¼**, ë„ì‹œì—ì„œ ìŠ¤í¬ì¸ ì™€ ì´ë²¤íŠ¸ë¥¼ ë‘˜ëŸ¬ì‹¼ ì˜ì‚¬ê²°ì •ì— ê³µí†µìœ¼ë¡œ ì°¸ì¡°ë˜ëŠ” **í™•ì¸ ë ˆì´ì–´**ë¡œ ê¸°ëŠ¥í•œë‹¤. | ì‚¬ìš©ì ìœ í˜• | Sportsiveê°€ ì œê³µí•˜ëŠ” ê°€ì¹˜ | | ------- | ------------------ | | ê°œì¸ ì‚¬ìš©ì | ì™¸ì¶œ ì „ â€œì§€ê¸ˆ ë­ë¼ë„ ìˆë‚˜?â€ | | ì§€ìì²´ | ë„ì‹œ ìŠ¤í¬ì¸  í™œì„±ë„, ë°€ì§‘ ê°€ëŠ¥ì„± | | ì´ë²¤íŠ¸ ìš´ì˜ì | ë‚ ì§œÂ·ì‹œê°„ëŒ€ ê²½ìŸ ê°•ë„ íŒë‹¨ | | í´ëŸ½Â·ë¦¬ê·¸ | ê²½ê¸°ì¼ì˜ ë„ì‹œ ë§¥ë½ íŒŒì•… | ì¤‘ìš”í•œ ì ì€, **ì§ˆë¬¸ì€ ë‹¤ë¥´ì§€ë§Œ ë³´ëŠ” í™”ë©´ì€ ë™ì¼í•˜ë‹¤ëŠ” ê²ƒ**ì´ë‹¤. ì´ëŠ” Sportsiveê°€ ì½˜í…ì¸  í”Œë«í¼ì´ ì•„ë‹ˆë¼ **ë„ì‹œ ë§¥ë½ì„ ê³µìœ í•˜ëŠ” ì¸í”„ë¼**ì„ì„ ì˜ë¯¸í•œë‹¤.

// src/app/sitemap.ts

import type { MetadataRoute } from "next";

export default function sitemap(): MetadataRoute.Sitemap {
  const baseUrl = "https://sportsive.vercel.app";

  return [
    {
      url: `${baseUrl}/`,
      lastModified: new Date(),
    },

    // ğŸ‡¬ğŸ‡§ UK
    {
      url: `${baseUrl}/uk/live-sports-today`,
      lastModified: new Date(),
    },
    {
      url: `${baseUrl}/uk/london/live-sports-today`,
      lastModified: new Date(),
    },
    {
      url: `${baseUrl}/uk/manchester/live-sports-today`,
      lastModified: new Date(),
    },
    {
      url: `${baseUrl}/uk/birmingham/live-sports-today`,
      lastModified: new Date(),
    },

    // ğŸ‡®ğŸ‡ª Ireland
    {
      url: `${baseUrl}/ireland/live-sports-today`,
      lastModified: new Date(),
    },
    {
      url: `${baseUrl}/ireland/dublin/live-sports-today`,
      lastModified: new Date(),
    },
    {
      url: `${baseUrl}/uk/sports-this-weekend`,
      lastModified: new Date(),
    },
    {
      url: `${baseUrl}/uk/london/sports-this-weekend`,
      lastModified: new Date(),
    },

  ];
}

// src/app/layout.tsx

import "./globals.css";
import type { Metadata, Viewport } from "next";
import { Inter } from "next/font/google";
import Providers from "./Providers";
import "@/lib/firebase";
import ClientShell from "./ClientShell";
import GoogleMapsProvider from "@/components/GoogleMapsProvider";
import { Analytics } from "@vercel/analytics/react";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
  display: "swap",
});

/* =========================
   METADATA (SEO + GSC)
========================= */
export const metadata: Metadata = {
  title: "Sportsive",
  description: "Discover sports you can actually attend near you",
  manifest: "/manifest.json",

  // âœ… Google Search Console verification
  verification: {
    google: "9OtVcxThar95vmRDQTol9vu8rJzHCq4A3EJ2CHn1Gs4",
  },

  // (ì„ íƒ) ê¸°ë³¸ OG â€” ë‚˜ì¤‘ì— SEO í˜ì´ì§€ë³„ë¡œ override ê°€ëŠ¥
  openGraph: {
    title: "Sportsive",
    description: "See what sports are happening near you, right now.",
    siteName: "Sportsive",
    type: "website",
  },
};

/* =========================
   VIEWPORT
========================= */
export const viewport: Viewport = {
  themeColor: "#2563eb",
};

/* =========================
   ROOT LAYOUT
========================= */
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className={`${inter.variable} h-full`}>
      <head>
        {/* âœ… Apple PWA */}
        <link rel="apple-touch-icon" href="/icons/icon-192.png" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta
          name="apple-mobile-web-app-status-bar-style"
          content="black-translucent"
        />
      </head>

      <body className="text-foreground antialiased">
        <Providers>
          <GoogleMapsProvider>
            <ClientShell>{children}</ClientShell>
          </GoogleMapsProvider>
        </Providers>

        {/* âœ… Google Analytics (GA4) */}
        <script
          async
          src="https://www.googletagmanager.com/gtag/js?id=G-1WRHN39RC6"
        />
        <script
          dangerouslySetInnerHTML={{
            __html: `
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-1WRHN39RC6', {
                debug_mode: true,
              });
            `,
          }}
        />

        {/* âœ… Vercel Analytics */}
        <Analytics />
      </body>
    </html>
  );
}

// src/lib/visitThrottle.ts
const KEY = "sportsive_last_visit_log_ts";
const GAP = 10 * 60 * 1000; // 10ë¶„

export function shouldLogVisit() {
  if (typeof window === "undefined") return false;

  const now = Date.now();
  const last = Number(localStorage.getItem(KEY) || 0);

  if (now - last < GAP) return false;

  localStorage.setItem(KEY, String(now));
  return true;
}

//src/lib/clientId.ts

export function getClientId(): string {
  if (typeof window === "undefined") {
    return "server";
  }

  const KEY = "sportsive_client_id";
  let id = localStorage.getItem(KEY);

  if (!id) {
    id = crypto.randomUUID();
    localStorage.setItem(KEY, id);
  }

  return id;
}

//src/lib/returnCheck.ts

const KEY = "sportsive_first_visit_ts";
const LIMIT = 24 * 60 * 60 * 1000; // 24h

export function isReturn24h(): boolean {
  if (typeof window === "undefined") return false;

  const now = Date.now();
  const first = localStorage.getItem(KEY);

  if (!first) {
    localStorage.setItem(KEY, String(now));
    return false; // ì²« ë°©ë¬¸
  }

  return now - Number(first) <= LIMIT;
}

//src/app/uk/football-today/page.tsx

import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "Football Matches in the UK Today | Sportsive",
  description:
    "Find football matches happening across the UK today. Premier League, Championship and other fixtures â€” with links to other live sports like horse racing, rugby, basketball, tennis and darts.",
};

export default function UKFootballTodayPage() {
  return (
    <main className="max-w-3xl mx-auto px-6 py-16 space-y-6">
      <h1 className="text-3xl font-bold">
        Football matches happening in the UK today
      </h1>

      <p className="text-muted-foreground">
        Looking for football matches in the UK today?
        This page helps you discover live football games happening across
        the United Kingdom, including Premier League, Championship, EFL League 1 and EFL League 2
        lower league fixtures.
      </p>

      <p className="text-muted-foreground">
        Football events are often spread across different club websites,
        making them hard to find unless you already know what youâ€™re looking for.
        Sportsive brings live sports together so you can quickly check
        whatâ€™s actually happening today.
      </p>

      <h2 className="text-xl font-semibold pt-4">
        Other live sports happening in the UK today
      </h2>

      <p className="text-muted-foreground">
        In addition to football, you can also discover other live sports
        happening across the UK today:
      </p>

      <ul className="list-disc pl-6 text-muted-foreground space-y-1">
        <li>
          <strong>Horse racing</strong> â€” race meetings across England, Scotland and Wales
        </li>
        <li>
          <strong>Rugby</strong> â€” Premiership Rugby and other domestic fixtures
        </li>
        <li>
          <strong>Basketball</strong> â€” Super League Basketball(SLB), British Basketball League games
        </li>
        <li>
          <strong>Tennis</strong> â€” tournaments and match sessions
        </li>
        <li>
          <strong>Darts</strong> â€” professional and tournament events
        </li>
      </ul>

      <h2 className="text-xl font-semibold pt-4">
        Ireland sports note
      </h2>

      <p className="text-muted-foreground">
        In Ireland, Sportsive currently focuses on horse racing events.
        You can explore Irish race meetings and sessions separately.
      </p>

      <ul className="list-disc pl-6 text-muted-foreground">
        <li>
          <a
            href="/ireland/horse-racing-today"
            className="underline underline-offset-4"
          >
            Horse racing in Ireland today
          </a>
        </li>
      </ul>

      <a
        href="/app"
        className="inline-block mt-6 underline underline-offset-4"
      >
        Open the live sports map
      </a>
    </main>
  );
}

///src/app/uk/live-sports-today/page.tsx

export const metadata = {
  title: "Live Sports in the UK Today | Sportsive",
  description:
    "Find live sports matches happening across the UK today. Football, rugby, tennis and more â€” shown by city, location and time.",
};

export default function UKLiveSportsTodayPage() {
  return (
    <main className="max-w-3xl mx-auto px-6 py-16 space-y-6">
      <h1 className="text-3xl font-bold">
        Live sports happening across the UK today
      </h1>

      <p className="text-muted-foreground">
        Looking for live sports happening in the UK today?
        This page helps you discover football, rugby, tennis and other
        sports matches taking place across major UK cities.
      </p>

      <p className="text-muted-foreground">
        Sports events are often hard to find unless you already follow
        specific teams or leagues. Sportsive shows whatâ€™s happening
        based on location and time â€” without accounts or subscriptions.
      </p>

      <ul className="list-disc pl-6 text-muted-foreground">
        <li>
          <a href="/uk/london/live-sports-today" className="underline">
            Live sports in London today
          </a>
        </li>
      </ul>

      <a
        href="/app"
        className="inline-block mt-6 underline underline-offset-4"
      >
        Open the live sports map
      </a>
    </main>
  );
}

///src/app/uk/london/live-sports-today/page.tsx

export const metadata = {
  title: "Live Sports in London Today | Sportsive",
  description:
    "See live sports matches happening in London today. Football, rugby, tennis and more â€” mapped by location and time.",
};

export default function LondonLiveSportsTodayPage() {
  return (
    <main className="max-w-3xl mx-auto px-6 py-16 space-y-6">
      <h1 className="text-3xl font-bold">
        Live sports happening in London today
      </h1>

      <p className="text-muted-foreground">
        Looking for live sports happening in London today?
        This page shows football, rugby, tennis and other matches
        taking place around London, based on location and time.
      </p>

      <p className="text-muted-foreground">
        Most sports events in London are difficult to find unless
        you already follow the right teams or venues.
        Sportsive makes it easy to quickly check whatâ€™s happening nearby.
      </p>

      <a
        href="/app"
        className="inline-block mt-6 underline underline-offset-4"
      >
        See whatâ€™s happening on the map right now
      </a>
    </main>
  );
}



// src/lib/analytics.ts

export type EventName =
  | "home_loaded"
  | "surprise_clicked"
  | "match_discovered"
  | "daily_discovery_completed"
  | "map_opened"
  | "map_closed"
  | "stamp_earned"
  | "details_opened"
  | "live_opened";

export type EventProps = Record<string, string>;

/**
 * ê°œë°œì(ë³¸ì¸) ì—¬ë¶€
 * - ë¡œì»¬ / dev í™˜ê²½: ìë™ true
 * - ë°°í¬ í™˜ê²½: NEXT_PUBLIC_IS_DEV=true ì¸ ë¸Œë¼ìš°ì €ë§Œ true
 */
const isDevUser =
  process.env.NODE_ENV !== "production" ||
  process.env.NEXT_PUBLIC_IS_DEV === "true";

export function logEvent(
  name: EventName | string,
  props?: EventProps
) {
  const finalProps: EventProps = {
    ...(props ?? {}),
    ...(isDevUser ? { is_dev: "true" } : {}),
  };

  if (process.env.NODE_ENV !== "production") {
    if (Object.keys(finalProps).length > 0) {
      console.log(`[analytics] ${name}`, finalProps);
    } else {
      console.log(`[analytics] ${name}`);
    }
  }

  // ë¯¸ë˜:
  // GA4:
  // logEvent(analytics, name, finalProps)

  // PostHog:
  // posthog.capture(name, finalProps)
}

// src/lib/eventTime.ts

export type EventTimeState =
  | "LIVE"
  | "SOON"
  | "UPCOMING"
  | "ENDED";

export function getDefaultDurationMs(e: {
  durationMs?: number;
  sport?: string;
}): number {
  if (e.durationMs) return e.durationMs;

  switch (e.sport) {
    case "football":
    case "rugby":
      return 2.5 * 60 * 60 * 1000;
    case "basketball":
      return 2 * 60 * 60 * 1000;
    case "tennis":
      return 3 * 60 * 60 * 1000;
    case "horse-racing":
      return 6 * 60 * 60 * 1000;
    default:
      return 2 * 60 * 60 * 1000;
  }
}

export function getSoonWindowMs(e: {
  soonWindowMs?: number;
  sport?: string;
}): number {
  if (e.soonWindowMs) return e.soonWindowMs;

  switch (e.sport) {
    case "tennis":
      return 60 * 60 * 1000;
    case "basketball":
      return 90 * 60 * 1000;
    case "horse-racing":
      return 4 * 60 * 60 * 1000;
    default:
      return 2 * 60 * 60 * 1000;
  }
}

export function getEventTimeState(
  e: {
    startDate?: string | Date;
    date?: string | Date;
    utcDate?: string | Date;
    durationMs?: number;
    soonWindowMs?: number;
    sport?: string;
  },
  now: Date = new Date()
): EventTimeState {
  const raw = e.startDate ?? e.date ?? e.utcDate;
  const start = new Date(raw as any);

  if (isNaN(start.getTime())) return "ENDED";

  const end = new Date(start.getTime() + getDefaultDurationMs(e));
  const diffMs = start.getTime() - now.getTime();

  if (now >= start && now <= end) return "LIVE";
  if (diffMs > 0 && diffMs <= getSoonWindowMs(e)) return "SOON";
  if (diffMs > 0) return "UPCOMING";

  return "ENDED";
}

// src/lib/nowDashboard.ts
import type { Event } from "@/types";

/**
 * NowHero / City status calculator
 * ì—­í• :
 * - ì´ë²¤íŠ¸ ì •ë³´ë¥¼ "ë„ì‹œ ìƒíƒœ(Pulse)"ë¡œ í•´ì„
 * - ìˆ«ìê°€ ì•„ë‹ˆë¼ 'ê²°ë¡  í•œ ì¤„'ì„ ë§Œë“ ë‹¤
 */

export type TimeScope = "today" | "tomorrow" | "weekend" | "week";

export type CityPulse =
  | "LIVE"
  | "WARMING_UP"
  | "QUIET";

export type NowStatus = {
  scope: TimeScope;
  kind: "live" | "next" | "empty";
  liveCount: number;
  nextAt: Date | null;
  count: number;

  pulse: CityPulse;   // âœ… í•µì‹¬
  text: string;       // âœ… ë„ì‹œ ìƒíƒœ í•œ ì¤„
};

/* ---------- helpers ---------- */

function getStartDate(e: any): Date | null {
  const raw = e.date ?? e.utcDate ?? e.startDate ?? null;
  if (!raw) return null;
  const d = new Date(raw);
  return isNaN(d.getTime()) ? null : d;
}

function startOfLocalDay(d: Date) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function isSameLocalDay(a: Date, b: Date) {
  return (
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate()
  );
}

function nextWeekendRange(now: Date) {
  const base = startOfLocalDay(now);
  const day = base.getDay();
  const toSat = day === 6 ? 0 : (6 - day + 7) % 7;
  const sat = new Date(base);
  sat.setDate(sat.getDate() + toSat);
  const mon = new Date(sat);
  mon.setDate(mon.getDate() + 2);
  return { start: sat, end: mon };
}

function formatTime(dt: Date) {
  return dt.toLocaleTimeString(undefined, {
    hour: "numeric",
    minute: "2-digit",
  });
}

function inScope(start: Date, scope: TimeScope, now: Date) {
  const base = startOfLocalDay(now);

  if (scope === "today") {
    return isSameLocalDay(start, now) && start >= now;
  }

  if (scope === "tomorrow") {
    const t0 = new Date(base);
    t0.setDate(t0.getDate() + 1);
    const t1 = new Date(t0);
    t1.setDate(t1.getDate() + 1);
    return start >= t0 && start < t1;
  }

  if (scope === "weekend") {
    const wk = nextWeekendRange(now);
    return start >= wk.start && start < wk.end;
  }

  const end = new Date(base);
  end.setDate(end.getDate() + 7);
  return start >= now && start < end;
}

/* ---------- NEW: í•´ì„ ë ˆì´ì–´ ---------- */

function getCityPulse(
  liveCount: number,
  nextAt: Date | null,
  now: Date
): CityPulse {
  if (liveCount > 0) return "LIVE";

  if (nextAt) {
    const diffH =
      (nextAt.getTime() - now.getTime()) / (1000 * 60 * 60);
    if (diffH <= 3) return "WARMING_UP";
  }

  return "QUIET";
}

function formatCityText(
  pulse: CityPulse,
  nextAt: Date | null
): string {
  if (pulse === "LIVE") {
    return "LIVE now Â· more happening later";
  }

  if (pulse === "WARMING_UP" && nextAt) {
    return `Next kickoff Â· ${formatTime(nextAt)}`;
  }

  if (nextAt) {
    return `Quiet now Â· next match at ${formatTime(nextAt)}`;
  }

  return "Quiet today Â· nothing scheduled";
}


/* ---------- main ---------- */

export function buildNowStatus(
  events: Event[],
  scope: TimeScope,
  now = new Date()
): NowStatus {
  let liveCount = 0;
  let nextAt: Date | null = null;
  let count = 0;

  for (const e of events as any[]) {
    const start = getStartDate(e);
    if (!start) continue;
    if (!inScope(start, scope, now)) continue;

    count += 1;

    const status = (e.status ?? "").toUpperCase();
    if (status === "LIVE") liveCount += 1;

    if (start > now) {
      if (!nextAt || start < nextAt) nextAt = start;
    }
  }

  const pulse = getCityPulse(liveCount, nextAt, now);

  return {
    scope,
    kind:
      pulse === "LIVE"
        ? "live"
        : pulse === "WARMING_UP"
        ? "next"
        : "empty",
    liveCount,
    nextAt,
    count,
    pulse,
    text: formatCityText(pulse, nextAt),
  };
}


// src/app/components/home/HomeMapStage.tsx
"use client";

import { forwardRef } from "react";
import type { Event } from "@/types";
import type { TimeScope } from "@/lib/nowDashboard";
import HomeEventMap, { HomeEventMapRef } from "@/app/components/map-hero/HomeEventMap";

type Props = {
  events: Event[];
  timeScope: TimeScope;
  onDiscoverFromMap: (eventId: string) => void;
  onBoundsChanged?: (bounds: google.maps.LatLngBoundsLiteral) => void;
};

const HomeMapStage = forwardRef<HomeEventMapRef, Props>(
  function HomeMapStage(
    { events, timeScope, onDiscoverFromMap, onBoundsChanged }, // âœ… ì—¬ê¸°!
    ref
  ) {
    return (
      <HomeEventMap
        ref={ref}
        events={events}
        timeScope={timeScope}          // âœ… ì •ìƒ
        onDiscover={onDiscoverFromMap}
        onBoundsChanged={onBoundsChanged}
      />
    );
  }
);

export default HomeMapStage;

// src/app/components/home/LocationSheet.tsx
"use client";

import { useMemo, useState } from "react";

export default function LocationSheet({
  regions,
  cities,
  observerRegion,
  onPickRegion,
  onPickCity,
  onClose,
}: {
  regions: string[];
  cities: string[];
  observerRegion: string | null;
  onPickRegion: (r: string | null) => void;
  onPickCity: (c: string) => void;
  onClose: () => void;
}) {
  const [query, setQuery] = useState("");

  const filteredCities = useMemo(() => {
    if (!query) return cities;
    return cities.filter((c) =>
      c.toLowerCase().includes(query.toLowerCase())
    );
  }, [cities, query]);

  return (
    <div className="fixed inset-0 z-50">
      {/* overlay */}
      <button
        className="absolute inset-0 bg-black/40"
        onClick={onClose}
        aria-label="Close"
      />

      {/* sheet */}
      <div
        className="
          absolute bottom-0 left-0 right-0
          bg-background
          rounded-t-2xl
          px-4 pt-3 pb-[env(safe-area-inset-bottom)]
          max-h-[70svh]
          overflow-y-auto
        "
      >
        {/* handle + close */}
        <div className="relative flex items-center justify-center mb-3">
          <div className="h-1.5 w-10 rounded-full bg-border/60" />
          <button
            onClick={onClose}
            className="absolute right-0 text-sm text-muted-foreground"
            aria-label="Close sheet"
          >
            âœ•
          </button>
        </div>

        {/* title */}
        <p className="text-sm font-semibold mb-3">Location</p>

        {/* REGION â€“ compact, progressive */}
        <div className="flex gap-2 overflow-x-auto pb-1 mb-4">
          <button
            onClick={() => onPickRegion(null)}
            className={[
              "shrink-0 px-3 py-1.5 rounded-full text-sm border",
              observerRegion === null
                ? "bg-black text-white border-black"
                : "border-border/60",
            ].join(" ")}
          >
            All
          </button>

          {regions.slice(0, 6).map((r) => {
            const active = r === observerRegion;
            return (
              <button
                key={r}
                onClick={() => onPickRegion(r)}
                className={[
                  "shrink-0 px-3 py-1.5 rounded-full text-sm border",
                  active
                    ? "bg-black text-white border-black"
                    : "border-border/60",
                ].join(" ")}
              >
                {r}
              </button>
            );
          })}
        </div>

        {/* CITY â€“ search first */}
        {observerRegion && (
          <div className="space-y-3">
            <input
              type="search"
              placeholder={`Search city in ${observerRegion}`}
              value={query}
              onChange={(e) => setQuery(e.target.value)}
              className="
                w-full h-11
                rounded-xl
                bg-muted/40
                px-4
                text-sm
                outline-none
              "
            />

            <div className="divide-y">
              {filteredCities.map((c) => (
                <button
                  key={c}
                  onClick={() => {
                    onPickCity(c);
                    onClose(); // âœ… ì„ íƒ ì¦‰ì‹œ ë‹«í˜ (2026 íŒ¨í„´)
                  }}
                  className="
                    w-full py-3
                    text-left text-sm
                    active:scale-[0.98]
                    transition
                  "
                >
                  {c}
                </button>
              ))}

              {filteredCities.length === 0 && (
                <p className="py-6 text-center text-sm text-muted-foreground">
                  No cities found
                </p>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// src/app/components/home/MapStatusPill.tsx

"use client";

import type { Event } from "@/types";

/* ---------------- helpers ---------------- */

function getStartDate(e: any): Date | null {
  const raw = e.date ?? e.utcDate ?? e.startDate ?? null;
  if (!raw) return null;
  const d = new Date(raw);
  return isNaN(d.getTime()) ? null : d;
}

function formatTime(dt: Date) {
  return dt.toLocaleTimeString(undefined, {
    hour: "numeric",
    minute: "2-digit",
  });
}

export type MapScope = "user" | "global" | "observer";

/* ---------------- component ---------------- */

export default function MapStatusPill({
  events,
  scope,
}: {
  events: Event[];
  scope: MapScope;
}) {
  if (events.length === 0) return null;

  const now = new Date(); // âœ… Date ê°ì²´ë¡œ í†µì¼

  let liveCount = 0;
  let nextAt: Date | null = null;

  for (const e of events as any[]) {
    const status = (e.status ?? "").toUpperCase();
    if (status === "LIVE") liveCount += 1;

    const start = getStartDate(e);
    if (start && start.getTime() > now.getTime()) {
      if (!nextAt || start < nextAt) nextAt = start;
    }
  }

  /* ---------------- where label ---------------- */

  const where =
    scope === "global"
      ? "across the map"
      : scope === "observer"
      ? "in this city"
      : "around you";

  let label = "";

  /* ---------------- LIVE ---------------- */

  if (liveCount > 0) {
    label =
      liveCount === 1
        ? `LIVE Â· 1 event ${where}`
        : `LIVE Â· ${liveCount} events ${where}`;
  }

  /* ---------------- UPCOMING ---------------- */

  else if (nextAt) {
    const t = formatTime(nextAt);

    const WINDOW_MS = 2 * 60 * 60 * 1000; // 2 hours
    const nextTs = nextAt.getTime();

    const clusteredCount = events.filter((e: any) => {
      const s = getStartDate(e);
      if (!s) return false;
      return Math.abs(s.getTime() - nextTs) <= WINDOW_MS;
    }).length;

    const diffMin = Math.round(
      (nextAt.getTime() - now.getTime()) / 60000
    );

    if (clusteredCount <= 2) {
      if (diffMin <= 60) {
        label = `Starting in ${diffMin} min Â· ${where}`;
      } else {
        label = `Starting later Â· ${t} Â· ${where}`;
      }
    } else if (clusteredCount <= 4) {
      label = `Warming up Â· ${t} Â· a few ${where}`;
    } else {
      label = `Busy later Â· ${t} Â· ${where}`;
    }
  }

  /* ---------------- QUIET ---------------- */

  else {
    label = `Quiet right now Â· ${where}`;
  }

  /* ---------------- render ---------------- */

  return (
    <div
      className="
        pointer-events-none
        fixed
        left-1/2 -translate-x-1/2
        bottom-[calc(env(safe-area-inset-bottom)+96px)]
        z-50
      "
    >
      <div
        className="
          rounded-full
          bg-black/85
          text-white
          text-xs
          font-semibold
          px-4
          py-2
          shadow-lg
          tracking-wide
          whitespace-nowrap
        "
      >
        {label}
      </div>
    </div>
  );
}

// src/app/components/home/NowHeroScopeBar.tsx

"use client";

import type { TimeScope } from "@/lib/nowDashboard";

export default function NowHeroScopeBar({
  scope,
  onScopeChange,
}: {
  scope: TimeScope;
  onScopeChange: (s: TimeScope) => void;
}) {
  return (
    <div
      className="
        inline-flex items-center
        rounded-full
        bg-background/60
        ring-1 ring-border/40
        p-1
      "
    >
      {(["today", "tomorrow", "weekend", "week"] as TimeScope[]).map((s) => (
        <button
          key={s}
          onClick={() => onScopeChange(s)}
          className={[
            "px-2.5 py-1.5 text-[12px] font-semibold rounded-full transition",
            scope === s
              ? "bg-foreground text-background shadow-sm"
              : "text-muted-foreground",
          ].join(" ")}
        >
          {s === "today" ? "Today" :
           s === "tomorrow" ? "Tomorrow" :
           s === "weekend" ? "Weekend" : "Week"}
        </button>
      ))}
    </div>
  );
}

//src/app/components/home/useDistanceUnit.ts

"use client";

import { useEffect, useState } from "react";
import { detectDefaultUnit, DistanceUnit } from "@/lib/distance";

const STORAGE_KEY = "sportsive_distance_unit";

export function useDistanceUnit() {
  const [unit, setUnit] = useState<DistanceUnit>("km");

  useEffect(() => {
    const saved = localStorage.getItem(STORAGE_KEY) as DistanceUnit | null;
    if (saved === "km" || saved === "mi") {
      setUnit(saved);
    } else {
      setUnit(detectDefaultUnit());
    }
  }, []);

  const toggle = () => {
    setUnit((prev) => {
      const next = prev === "km" ? "mi" : "km";
      localStorage.setItem(STORAGE_KEY, next);
      return next;
    });
  };

  return { unit, toggle };
}

//src/app/components/home/useLocationMode.ts

"use client";

import { useUserLocation } from "./useUserLocation";

export type LocationMode =
  | "observer"   // ìœ„ì¹˜ ì—†ìŒ (ê¸°ë³¸)
  | "located";   // ìœ„ì¹˜ ìˆìŒ

export function useLocationMode(): {
  mode: LocationMode;
  hasLocation: boolean;
} {
  const { pos } = useUserLocation();

  if (pos) {
    return { mode: "located", hasLocation: true };
  }

  return { mode: "observer", hasLocation: false };
}

//src/app/components/home/useUserLocation.ts

"use client";

import { useEffect, useState } from "react";

export type LatLng = { lat: number; lng: number };

export function useUserLocation(options?: { enabled?: boolean }) {
  const [pos, setPos] = useState<LatLng | null>(null);
  const [denied, setDenied] = useState(false);

  useEffect(() => {
    if (options?.enabled === false) return;
    if (!navigator.geolocation) return;

    navigator.geolocation.getCurrentPosition(
      (p) => {
        setPos({ lat: p.coords.latitude, lng: p.coords.longitude });
      },
      () => setDenied(true),
      { enableHighAccuracy: false, timeout: 7000 }
    );
  }, [options?.enabled]);

  return { pos, denied };
}

export function haversineKm(a: LatLng, b: LatLng) {
  const toRad = (x: number) => (x * Math.PI) / 180;
  const R = 6371;

  const dLat = toRad(b.lat - a.lat);
  const dLng = toRad(b.lng - a.lng);

  const s1 =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(a.lat)) * Math.cos(toRad(b.lat)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);

  const c = 2 * Math.atan2(Math.sqrt(s1), Math.sqrt(1 - s1));
  return R * c;
}

// src/app/api/go/ticket/route.ts
import { NextRequest, NextResponse } from "next/server";
import { supabase } from "../../../../lib/supabaseServer";

/**
 * Ticket click = high-intent action
 * This log is the KPI source of truth for investor conversations.
 */
type TicketClickLog = {
  type: "ticket_click";
  ts: string;
  eventId: string;
  sport: string | null;
  city: string | null;

  // where the click happened
  source: "snap_card" | "map" | "list" | "unknown";

  userAgent: string | null;
  ip: string | null;
  referrer: string | null;
};

async function logTicketClick(log: TicketClickLog) {
  await supabase.from("ticket_clicks").insert({
    event_id: log.eventId,
    sport: log.sport,
    city: log.city,
    source: log.source,
  });
}

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);

  const eventId = searchParams.get("eventId");
  const target = searchParams.get("target");

  if (!eventId || !target) {
    return NextResponse.json({ error: "Bad request" }, { status: 400 });
  }

  // âœ… Validate target URL (security & data integrity)
  try {
    new URL(target);
  } catch {
    return NextResponse.json({ error: "Invalid target" }, { status: 400 });
  }

  // âœ… Click source (default: unknown)
  const sourceParam = searchParams.get("source");
  const source: TicketClickLog["source"] =
    sourceParam === "snap_card" ||
    sourceParam === "map" ||
    sourceParam === "list"
      ? sourceParam
      : "unknown";

  // âœ… Client IP extraction (proxy / Vercel safe)
  const forwardedFor = req.headers.get("x-forwarded-for");
  const ip = forwardedFor
    ? forwardedFor.split(",")[0].trim()
    : null;

  await logTicketClick({
    type: "ticket_click",
    ts: new Date().toISOString(),
    eventId,
    sport: searchParams.get("sport"),
    city: searchParams.get("city"),
    source,
    userAgent: req.headers.get("user-agent"),
    ip,
    referrer: req.headers.get("referer"),
  });

  // âœ… Redirect after logging
  return NextResponse.redirect(target, { status: 302 });
}


// src/app/components/map-hero/HomeEventMap.tsx

"use client";

import {
  useEffect,
  useRef,
  useState,
  forwardRef,
  useImperativeHandle,
} from "react";
import type { Event } from "@/types";
import { useGoogleMaps } from "@/components/GoogleMapsProvider";
import type { TimeScope } from "@/lib/nowDashboard";
import { getEventTimeState, getDefaultDurationMs } from "@/lib/eventTime";


const DEFAULT_ZOOM = 8;
const FOCUS_ZOOM = 16;
const UK_CENTER = { lat: 54.5, lng: -3.0 };
const UK_ZOOM = 7;

// ======== Signal spec constants ========
const SOON_WINDOW_MS = 2 * 60 * 60 * 1000; // 2h
const PRESENCE_RECENT_MS = 2 * 60 * 1000; // 2m "someone just opened this"
const PRESENCE_FADE_MS = 8 * 60 * 1000; // 8m "was here a moment ago"

type MarkerStatus = "DEFAULT" | "SOON" | "LIVE";

function getEventStart(e: Event): Date | null {
  const raw = (e as any).date ?? (e as any).utcDate ?? (e as any).startDate;
  if (!raw) return null;
  const d = new Date(raw);
  return isNaN(d.getTime()) ? null : d;
}

function getMarkerStatus(e: Event): MarkerStatus {
  const state = getEventTimeState(e);

  if (state === "LIVE") return "LIVE";
  if (state === "SOON") return "SOON";
  return "DEFAULT";
}


function markerBaseScaleForZoom(zoom: number) {
  if (zoom >= 14) return 4.8;
  if (zoom >= 12) return 5.4;
  if (zoom >= 10) return 6.0;
  return 6.6;
}

function thinByGrid(events: Event[], zoom: number) {
  const cellKm =
    zoom <= 10 ? 8 :
    zoom <= 12 ? 4 :
    2;

  const grid = new Map<string, Event>();

  for (const e of events) {
    if (!e.location) continue;

    const key =
      Math.floor(e.location.lat / (cellKm / 110)) + ":" +
      Math.floor(e.location.lng / (cellKm / 110));

    const prev = grid.get(key);
    if (!prev) {
      grid.set(key, e);
      continue;
    }

    // ìš°ì„ ìˆœìœ„: LIVE > SOON > DEFAULT
    const p = getMarkerStatus(prev);
    const n = getMarkerStatus(e);

    if (
      (n === "LIVE" && p !== "LIVE") ||
      (n === "SOON" && p === "DEFAULT")
    ) {
      grid.set(key, e);
    }
  }

  return Array.from(grid.values());
}

function computePulse(phase: number) {
  // phase: 0..1
  // smooth pulse in [0..1]
  const t = phase * Math.PI * 2;
  return (Math.sin(t) + 1) / 2;
}

function getMarkerIcon(e: Event, zoom: number, phase: number): google.maps.Symbol {
  const status = getMarkerStatus(e);

  const base = markerBaseScaleForZoom(zoom);

  // Default is intentionally low presence so LIVE/SOON pops by contrast
  let fillColor = "#0f172a";
  let fillOpacity = 0.48;        // â¬…ï¸ í™•ì‹¤íˆ ë³´ì´ê²Œ
  let scale = base * 1.1;
  // Live/Soon: signal, not POI
  if (status === "SOON") {
    // subtle pulse; still readable
    const p = computePulse(phase);
    fillColor = "#ef4444";
    fillOpacity = 0.70 + p * 0.18; // 0.70..0.88
    scale = base * (1.08 + p * 0.08); // 1.08..1.16
  }

  if (status === "LIVE") {
    // stronger pulse
    const p = computePulse(phase);
    fillColor = "#ef4444";
    fillOpacity = 0.82 + p * 0.15; // 0.82..0.97
    scale = base * (1.18 + p * 0.12); // 1.18..1.30
  }

  return {
    path: google.maps.SymbolPath.CIRCLE,
    scale,
    fillColor,
    fillOpacity,
    // add a subtle stroke to lift off the light map (this is what makes it "seen")
    strokeColor: "rgba(255,255,255,0.85)",
    strokeOpacity: status === "DEFAULT" ? 0.75 : 0.85,
    strokeWeight: status === "DEFAULT" ? 1.5 : 2,
  };
}

function getHaloIcon(zoom: number, phase: number): google.maps.Symbol {
  // A thin ring for SOON (and optionally LIVE) â€” helps "this is a signal" readability
  const base = markerBaseScaleForZoom(zoom);

  const p = computePulse(phase);
  const scale = base * (1.55 + p * 0.15); // expanding ring
  const opacity = 0.20 + p * 0.18;

  return {
    path: google.maps.SymbolPath.CIRCLE,
    scale,
    fillOpacity: 0,
    strokeColor: "rgba(239,68,68,1)",
    strokeOpacity: opacity,
    strokeWeight: 2,
  };
}

// =========================
// (ê¸°ì¡´ íˆíŠ¸ë§µ ë³´ì¡° í•¨ìˆ˜ë“¤: ë‚¨ê²¨ë‘  â€” í˜¹ì‹œ ë‹¤ë¥¸ ê³³ì—ì„œ ì°¸ì¡°í•  ìˆ˜ ìˆì–´ ìœ ì§€)
// âš ï¸ ë‹¨, google.maps.visualization íƒ€ì…ì€ ì œê±°(visualization lib ì œê±°í–ˆê¸° ë•Œë¬¸)
// =========================
function buildHeatmapPoints(events: Event[]) {
  return events
    .filter((e) => e.location?.lat && e.location?.lng)
    .map((e) => {
      const status = getMarkerStatus(e);

      // weight is "influence", not color
      let weight = 1;
      if (status === "LIVE") weight = 3;
      else if (status === "SOON") weight = 2;

      return {
        location: new google.maps.LatLng(e.location!.lat, e.location!.lng),
        weight,
      };
    });
}

function spreadPoints(
  lat: number,
  lng: number,
  weight: number,
  zoom: number
): any[] {
  // zoomì´ ë‚®ì„ìˆ˜ë¡ ë” ë„“ê²Œ í¼ì§
  const spreadMeters =
    zoom <= 6 ? 6000 :
    zoom <= 7 ? 3500 :
    zoom <= 8 ? 2000 :
    800;

  // weightì´ í´ìˆ˜ë¡ ì  ê°œìˆ˜ ì¦ê°€
  const count = Math.round(weight * 4);

  const points: any[] = [];

  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const radius = Math.random() * spreadMeters;

    // meters â†’ lat/lng ë³€í™˜
    const dLat = (radius * Math.cos(angle)) / 111_000;
    const dLng =
      (radius * Math.sin(angle)) /
      (111_000 * Math.cos((lat * Math.PI) / 180));

    points.push({
      location: new google.maps.LatLng(lat + dLat, lng + dLng),
      weight: 1,
    });
  }

  return points;
}

function heatmapRadiusForZoom(zoom: number) {
  if (zoom <= 6) return 26;
  if (zoom === 7) return 34;
  if (zoom === 8) return 44;
  if (zoom === 9) return 58;
  return 0;
}

// =========================
// âœ… NEW: Soft Density (Canvas Overlay) helpers
// =========================
function densityRadiusPxForZoom(zoom: number) {
  // â€œê·¼ì²˜â€ ê°ê°: zoom ë‚®ì„ìˆ˜ë¡ ë„“ê²Œ
  if (zoom <= 6) return 58;
  if (zoom === 7) return 50;
  if (zoom === 8) return 40;
  if (zoom === 9) return 32;
  return 0;
}

function densityBlurPxForZoom(zoom: number) {
  if (zoom <= 6) return 38;
  if (zoom === 7) return 32;
  if (zoom === 8) return 24;
  if (zoom === 9) return 18;
  return 0;
}

function densityBaseAlphaForZoom(zoom: number) {
  // ì „ì²´ê°€ ê³¼í•˜ê²Œ ë¿Œì˜‡ê²Œ ë˜ëŠ” ê±¸ ë°©ì§€ (zoom ë‚®ì„ìˆ˜ë¡ ë” ì˜…ê²Œ)
  if (zoom <= 6) return 0.12;
  if (zoom === 7) return 0.14;
  if (zoom === 8) return 0.16;
  if (zoom === 9) return 0.18;
  return 0;
}

function getDensityWeight(e: Event, scope: TimeScope, now: Date) {
  const start = getEventStart(e);
  if (!start) return 0;

  // =====================
  // session íŒë³„
  // =====================
  const isSession =
    (e as any).kind === "session" &&
    (e as any).startDate &&
    (e as any).endDate;

  const graceMs = 15 * 60 * 1000; // ğŸ”§ 15ë¶„ ì—¬ìœ  (ì·¨í–¥)

  const sessionStart = isSession
    ? new Date((e as any).startDate)
    : start;

  const sessionEnd = isSession
    ? new Date((e as any).endDate)
    : new Date(start.getTime() + getDefaultDurationMs(e) + graceMs);


  // =====================
  // scope ë²”ìœ„ ê³„ì‚°
  // =====================
  const base = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  let scopeStart: Date;
  let scopeEnd: Date;

  switch (scope) {
    case "today":
      scopeStart = base;
      scopeEnd = new Date(base.getTime() + 24 * 60 * 60 * 1000);
      break;

    case "tomorrow":
      scopeStart = new Date(base.getTime() + 24 * 60 * 60 * 1000);
      scopeEnd = new Date(base.getTime() + 48 * 60 * 60 * 1000);
      break;

    case "weekend": {
      const day = base.getDay(); // 0 Sun ... 6 Sat
      const toSat = day === 6 ? 0 : (6 - day + 7) % 7;
      const sat = new Date(base);
      sat.setDate(sat.getDate() + toSat);
      scopeStart = sat;
      scopeEnd = new Date(sat.getTime() + 2 * 24 * 60 * 60 * 1000);
      break;
    }

    case "week":
    default:
      scopeStart = now;
      scopeEnd = new Date(base.getTime() + 7 * 24 * 60 * 60 * 1000);
      break;
  }

  // =====================
  // scopeì™€ ê²¹ì¹˜ëŠ”ì§€ íŒë‹¨ (ğŸ”¥ í•µì‹¬)
  // =====================
  const inScope = isSession
    ? sessionStart < scopeEnd && sessionEnd > scopeStart
    : start >= scopeStart && start < scopeEnd;

  if (!inScope) return 0;

  // =====================
  // ê°€ì¤‘ì¹˜ ê³„ì‚° (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
  // =====================
  const sport = ((e as any).sport ?? "").toString().toLowerCase();
  const format = ((e as any).format ?? "").toString().toLowerCase();
  const kind = ((e as any).kind ?? "").toString().toLowerCase();

  const isTournament =
    format === "tournament" ||
    kind === "tournament" ||
    sport === "darts" || // âœ… ë‹¤íŠ¸ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í† ë„ˆë¨¼íŠ¸ê¸‰
    (sport === "tennis" && (format === "event" || format === "tourney"));

  const diffH = (start.getTime() - now.getTime()) / (1000 * 60 * 60);

  if (scope === "today") {
    if (isTournament) return 0.6;
    if (diffH > 6) return 0.15;
    if (diffH > 3) return 0.30;
    if (diffH > 1) return 0.60;
    if (diffH > 0.25) return 1.00;
    return 1.20;
  }

  if (scope === "tomorrow") {
    return isTournament ? 0.40 : 0.35;
  }

  if (scope === "weekend") {
    return isTournament ? 0.40 : 0.45;
  }

  return isTournament ? 0.30 : 0.25;
}

export interface HomeEventMapRef {
  surprise: () => void;
  focus: (eventId: string) => void;
  closeSnap: () => void;
  panTo: (latlng: { lat: number; lng: number }) => void;
  resetToAll: () => void;
}

type MarkerBundle = {
  eventId: string;
  status: MarkerStatus;
  main: google.maps.Marker;
  halo?: google.maps.Marker;
};

const HomeEventMap = forwardRef<
  HomeEventMapRef,
  {
    events: Event[];
    onDiscover: (eventId: string) => void;
    children?: React.ReactNode;
    onBoundsChanged?: (bounds: google.maps.LatLngBoundsLiteral) => void;

    // âœ… NEW: scopeë¥¼ Density ë ˆì´ì–´ì— ì£¼ì… (ì„ íƒ)
    // ì§€ê¸ˆ ë‹¹ì¥ ë‹¤ë¥¸ íŒŒì¼ ì•ˆ ê³ ì³ë„ ë¹Œë“œë˜ë„ë¡ optional + ê¸°ë³¸ê°’ today
    timeScope?: TimeScope;
  }
>(({ events, onDiscover, children, onBoundsChanged, timeScope }, ref) => {
  const mapRef = useRef<google.maps.Map | null>(null);

  const prevViewRef = useRef<{
    center: google.maps.LatLngLiteral;
    zoom: number;
  } | null>(null);

  const containerRef = useRef<HTMLDivElement | null>(null);

  // replaces markersRef: we need bundles (main + optional halo + presence)
  const markerBundlesRef = useRef<MarkerBundle[]>([]);

  // âŒ HeatmapLayer removed (deprecated May 2026)
  // const heatmapRef = useRef<google.maps.visualization.HeatmapLayer | null>(null);

  // âœ… Density overlay refs
  const densityOverlayRef = useRef<google.maps.OverlayView | null>(null);
  const densityEventsRef = useRef<Event[]>([]);
  const densityScopeRef = useRef<TimeScope>("today");
  const densityActiveRef = useRef<boolean>(false);

  const { isLoaded } = useGoogleMaps();

  const [selectedEvent, setSelectedEvent] = useState<Event | null>(null);
  const [showSnap, setShowSnap] = useState(false);
  const [viewportTick, setViewportTick] = useState(0);
  const [mapActive, setMapActive] = useState(false);
  const [mapReady, setMapReady] = useState(false);
  const ignoreNextBoundsRef = useRef(false);
  const [zoomTick, setZoomTick] = useState(0);

  // âœ… signal animation phase (0..1)
  const phaseRef = useRef(0);
  const [signalTick, setSignalTick] = useState(0);

  const getZoom = () => mapRef.current?.getZoom?.() ?? 0;

  const isDensity =
    mapReady && !mapActive && getZoom() <= 9;

  const SPORTSIVE_MAP_STYLE: google.maps.MapTypeStyle[] = [
    { featureType: "road", elementType: "labels", stylers: [{ visibility: "off" }] },
    { featureType: "poi", elementType: "labels", stylers: [{ visibility: "off" }] },
    { featureType: "administrative", elementType: "geometry.stroke", stylers: [{ visibility: "off" }] },
    {
      featureType: "administrative.locality",
      elementType: "labels.text.fill",
      stylers: [{ visibility: "on" }, { color: "#9ca3af" }, { weight: 0.4 }],
    },
    {
      featureType: "administrative.locality",
      elementType: "labels.text.stroke",
      stylers: [{ visibility: "on" }, { color: "#ffffff" }, { weight: 3 }],
    },
    {
      featureType: "administrative.country",
      elementType: "labels.text.fill",
      stylers: [{ visibility: "on" }, { color: "#cbd5e1" }, { weight: 0.3 }],
    },
    {
      featureType: "administrative.country",
      elementType: "labels.text.stroke",
      stylers: [{ visibility: "on" }, { color: "#ffffff" }, { weight: 4 }],
    },
    { featureType: "poi.park", elementType: "geometry", stylers: [{ visibility: "on" }, { color: "#d9f0e3" }] },
    { featureType: "road", elementType: "geometry", stylers: [{ color: "#d1d5db" }, { weight: 0.6 }] },
    { featureType: "landscape", elementType: "geometry", stylers: [{ color: "#f1f5f9" }] },
    { featureType: "water", elementType: "geometry", stylers: [{ color: "#e0f2fe" }] },
    { featureType: "transit", elementType: "all", stylers: [{ visibility: "off" }] },
  ];

  const resetMap = () => {
    if (mapRef.current && prevViewRef.current) {
      mapRef.current.panTo(prevViewRef.current.center);
      mapRef.current.setZoom(prevViewRef.current.zoom);
    }

    prevViewRef.current = null;
    setShowSnap(false);
    setSelectedEvent(null);
    setMapActive(false);
  };

  const focusById = (eventId: string) => {
    if (!mapRef.current) return;

    // âœ… ì´ì „ ë·° ì €ì¥ (ì²˜ìŒ ì§„ì… ì‹œë§Œ)
    if (!prevViewRef.current) {
      const center = mapRef.current.getCenter();
      const zoom = mapRef.current.getZoom();

      if (center && typeof zoom === "number") {
        prevViewRef.current = {
          center: { lat: center.lat(), lng: center.lng() },
          zoom,
        };
      }
    }

    const picked = (events as any[]).find((x) => x.id === eventId);
    if (!picked?.location) return;

    setMapActive(true);

    mapRef.current.panTo(picked.location);
    mapRef.current.setZoom(FOCUS_ZOOM);

    setTimeout(() => {
      setSelectedEvent(picked);
      setShowSnap(true);
    }, 300);

    onDiscover(picked.id);
  };

  useImperativeHandle(ref, () => ({
    surprise() {},
    focus(eventId) {
      focusById(eventId);
    },
    closeSnap() {
      resetMap();
    },
    panTo(latlng) {
      if (!mapRef.current) return;
      mapRef.current.panTo(latlng);
      mapRef.current.setZoom(12);
    },
    resetToAll() {
      if (!mapRef.current) return;

      ignoreNextBoundsRef.current = true;

      setMapActive(false);
      setSelectedEvent(null);
      setShowSnap(false);

      mapRef.current.panTo(UK_CENTER);
      mapRef.current.setZoom(UK_ZOOM);
    },
  }));

  useEffect(() => {
    if (!mapRef.current) return;

    const ro = new ResizeObserver(() => {
      google.maps.event.trigger(mapRef.current!, "resize");
    });

    ro.observe(containerRef.current!);
    return () => ro.disconnect();
  }, []);


  // âœ… 1) signal animation (safe): update phase + bump tick every ~900ms
  useEffect(() => {
    const id = window.setInterval(() => {
      phaseRef.current = (phaseRef.current + 0.14) % 1; // slow breathe
      setSignalTick((t) => t + 1);
    }, 900);
    return () => window.clearInterval(id);
  }, []);

  // âœ… 2) Density overlay (Canvas) â€” replaces HeatmapLayer
  useEffect(() => {
    if (!mapRef.current || !isLoaded) return;

    // keep latest refs for overlay.draw()
    densityEventsRef.current = events;
    densityScopeRef.current = (timeScope ?? "today");
    densityActiveRef.current = isDensity;

    const map = mapRef.current;

    // create overlay once
    if (!densityOverlayRef.current) {
      class DensityOverlay extends google.maps.OverlayView {
        private canvas: HTMLCanvasElement | null = null;
        private ctx: CanvasRenderingContext2D | null = null;

        onAdd() {
          const canvas = document.createElement("canvas");
          canvas.style.position = "absolute";
          canvas.style.top = "0";
          canvas.style.left = "0";
          canvas.style.width = "100%";
          canvas.style.height = "100%";
          canvas.style.pointerEvents = "none";
          canvas.style.zIndex = "2";

          // âœ… íƒ€ì… ì•ˆì „: mapRefì˜ map ì‚¬ìš©
          const mapDiv = map.getDiv() as HTMLElement;
          mapDiv.appendChild(canvas);

          this.canvas = canvas;
          this.ctx = canvas.getContext("2d");
        }

        onRemove() {
          if (this.canvas?.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas);
          }
          this.canvas = null;
          this.ctx = null;
        }

        draw() {
          if (!this.canvas || !this.ctx) return;

          const projection = this.getProjection();
          if (!projection) return;

          const mapDiv = map.getDiv() as HTMLElement;
          const w = mapDiv.clientWidth;
          const h = mapDiv.clientHeight;

          const dpr = window.devicePixelRatio || 1;

          if (
            this.canvas.width !== Math.floor(w * dpr) ||
            this.canvas.height !== Math.floor(h * dpr)
          ) {
            this.canvas.width = Math.floor(w * dpr);
            this.canvas.height = Math.floor(h * dpr);
            this.canvas.style.width = `${w}px`;
            this.canvas.style.height = `${h}px`;
          }

          const ctx = this.ctx;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.clearRect(0, 0, w, h);

          if (!densityActiveRef.current) return;

          const zoom = map.getZoom() ?? 0;
          const radius = densityRadiusPxForZoom(zoom);
          const blur = densityBlurPxForZoom(zoom);
          const baseAlpha = densityBaseAlphaForZoom(zoom);

          if (radius <= 0 || baseAlpha <= 0) return;

          const now = new Date();
          const scope = densityScopeRef.current;
          const evs = densityEventsRef.current;

          const color = "15,23,42"; // #0f172a

          for (const e of evs) {
            if (!e.location?.lat || !e.location?.lng) continue;

            const wgt = getDensityWeight(e, scope, now);
            if (wgt <= 0) continue;

            const p = projection.fromLatLngToContainerPixel(
              new google.maps.LatLng(e.location.lat, e.location.lng)
            );
            if (!p) continue;

            const alpha = Math.min(0.52, baseAlpha * wgt);

            ctx.save();
            ctx.beginPath();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = `rgba(${color},1)`;
            ctx.shadowColor = `rgba(${color},1)`;
            ctx.shadowBlur = blur;

            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          }
        }
      }

      densityOverlayRef.current = new DensityOverlay();
      densityOverlayRef.current.setMap(map);
    }



    // toggle attach/detach
    if (!densityActiveRef.current) {
      densityOverlayRef.current?.setMap(null);
      return;
    }

    densityOverlayRef.current.setMap(map);
    // force redraw on events/scope updates
    // @ts-ignore
    densityOverlayRef.current.draw?.();
  }, [events, isLoaded, mapActive, viewportTick, timeScope, zoomTick]);

  // âœ… 3) create map once
  useEffect(() => {
    if (!isLoaded || !containerRef.current) return;
    if (mapRef.current) return;

    mapRef.current = new google.maps.Map(containerRef.current, {
      center: UK_CENTER,
      zoom: UK_ZOOM,
      styles: SPORTSIVE_MAP_STYLE,
      clickableIcons: false,
      gestureHandling: "greedy",
      draggable: true,
      zoomControl: false,
      fullscreenControl: false,
      streetViewControl: false,
    });

    setMapReady(true);

    mapRef.current.addListener("click", () => {
      if (mapActive) resetMap();
    });
  }, [isLoaded]);

  // âœ… 4) marker bundles create/update (when not density mode)
  useEffect(() => {
    if (!mapRef.current) return;

    // density mode: clear markers
    if (isDensity) {
      markerBundlesRef.current.forEach((b) => {
        b.main.setMap(null);
        b.halo?.setMap(null);
      });
      markerBundlesRef.current = [];
      return;
    }

    // clear existing
    markerBundlesRef.current.forEach((b) => {
      b.main.setMap(null);
      b.halo?.setMap(null);
    });
    markerBundlesRef.current = [];

    const z = mapRef.current.getZoom() ?? 12;
    const phase = phaseRef.current;

    const visibleEvents =
      z >= 10 ? thinByGrid(events, z) : events;

    visibleEvents.forEach((e) => {
      if (!e.location) return;

      const status = getMarkerStatus(e);

      const main = new google.maps.Marker({
        position: e.location,
        map: mapRef.current!,
        title: (e as any).title ?? "",
        icon: getMarkerIcon(e, z, phase),
        clickable: true,
        zIndex: status === "LIVE" ? 30 : status === "SOON" ? 20 : 10,
        shape: { type: "circle", coords: [0, 0, 18] },
      });
      main.addListener("click", () => {
        focusById((e as any).id);
      });

      let halo: google.maps.Marker | undefined;
      if (status === "SOON" || status === "LIVE") {
        halo = new google.maps.Marker({
          position: e.location,
          map: mapRef.current!,
          clickable: false,
          icon: getHaloIcon(z, phase),
          zIndex: status === "LIVE" ? 25 : 15,
        });
      }
      // If you want LIVE ring too, uncomment:
      // if (status === "LIVE") { ... }

      markerBundlesRef.current.push({
        eventId: (e as any).id,
        status,
        main,
        halo,
      });
    });
  }, [events, events.length, viewportTick, mapActive, zoomTick, isDensity]);

  // âœ… 5) animate icons without recreating markers (cheap updates)
  useEffect(() => {
    if (!mapRef.current) return;
    if (isDensity) return;

    const z = mapRef.current.getZoom() ?? 12;
    const phase = phaseRef.current;

    for (const b of markerBundlesRef.current) {
      // We need event object to compute status; but we stored status at creation-time.
      // Status can change as time passes (SOON->LIVE), so re-evaluate from events list.
      const ev = (events as any[]).find((x) => x.id === b.eventId) as Event | undefined;
      if (!ev) continue;

      const statusNow = getMarkerStatus(ev);
      b.status = statusNow;

      b.main.setIcon(getMarkerIcon(ev, z, phase));
      b.main.setZIndex(statusNow === "LIVE" ? 30 : statusNow === "SOON" ? 20 : 10);

      // Halo: only for SOON
      if (statusNow === "SOON" || statusNow === "LIVE") {
        if (!b.halo) {
          b.halo = new google.maps.Marker({
            position: ev.location!,
            map: mapRef.current!,
            clickable: false,
            icon: getHaloIcon(z, phase),
            zIndex: 15,
          });
        } else {
          b.halo.setIcon(getHaloIcon(z, phase));
          b.halo.setMap(mapRef.current!);
        }
      } else {
        b.halo?.setMap(null);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [signalTick, events]);

  // âœ… 6) idle listener: viewportTick, densityâ†”markers hint, bounds
  const lastDensityRef = useRef<boolean | null>(null);
  
  useEffect(() => {
    if (!mapRef.current) return;

    const zListener = mapRef.current.addListener("zoom_changed", () => {
      setZoomTick((t) => t + 1);
    });

    return () => zListener.remove();
  }, []);

  useEffect(() => {
    if (!mapRef.current) return;

    const listener = mapRef.current.addListener("idle", () => {
      setViewportTick((v) => v + 1);

      const zoom = mapRef.current!.getZoom() ?? 0;

      // zoom out â†’ end active â†’ density mode
      if (zoom <= 9 && mapActive) {
        setMapActive(false);
        setSelectedEvent(null);
        setShowSnap(false);
      }

      // âœ… íˆíŠ¸ë§µ â†” ë§ˆì»¤ ì „í™˜ íŒíŠ¸
      const isDensityNow = !mapActive && zoom <= 8;
      if (lastDensityRef.current === null) {
        lastDensityRef.current = isDensityNow;
      } else if (lastDensityRef.current !== isDensityNow) {
        lastDensityRef.current = isDensityNow;
      }

      if (ignoreNextBoundsRef.current) {
        ignoreNextBoundsRef.current = false;
        return;
      }

      const b = mapRef.current!.getBounds();
      if (!b) return;

      onBoundsChanged?.({
        north: b.getNorthEast().lat(),
        east: b.getNorthEast().lng(),
        south: b.getSouthWest().lat(),
        west: b.getSouthWest().lng(),
      });
    });

    return () => listener.remove();
  }, [onBoundsChanged, mapActive]);

  return (
    <div className="fixed inset-0 overflow-visible">
      {/* RADAR OVERLAY */}
      {!isDensity && (
        <div
          className="pointer-events-none absolute inset-0 z-10"
          style={{
            background: `
              radial-gradient(
                circle at center,
                rgba(255,255,255,0) 0%,
                rgba(255,255,255,0) 55%,
                rgba(15,23,42,0.35) 70%,
                rgba(15,23,42,0.55) 100%
              )
            `,
          }}
        />
      )}

      {/* MAP CANVAS */}
      <div ref={containerRef} className="absolute inset-0" />

      {/* OPTIONAL CHILDREN OVER MAP */}
      <div className="absolute top-3 left-1/2 -translate-x-1/2 z-20 w-[calc(100%-24px)] max-w-3xl">
        {children}
      </div>
      {/* âŒ Removed: "Tap a marker..." */}
    </div>
  );
});

export default HomeEventMap;

// src/app/components/map-hero/HomeMapSnapCard.tsx
"use client";

import type { Event } from "@/types";
import { useMemo } from "react";
import { getVibe } from "@/lib/vibe";
import { track } from "@/lib/track";
import { useUserLocation, haversineKm } from "@/app/components/home/useUserLocation";
import { useDistanceUnit } from "@/app/components/home/useDistanceUnit";
import { formatDistance } from "@/lib/distance";
import { getEventTimeState } from "@/lib/eventTime";
import { useShare } from "@/hooks/useShare"; 

/* ---------------- helpers ---------------- */

function getAnchorDate(e: any): Date | null {
  const raw = e.date ?? e.utcDate ?? e.startDate ?? null;
  if (!raw) return null;
  const d = new Date(raw);
  return isNaN(d.getTime()) ? null : d;
}

function formatStartsLabel(e: any) {
  const state = getEventTimeState(e);

  if (state === "LIVE") {
    return { tone: "live" as const, text: "LIVE" };
  }

  if (state === "SOON") {
    return { tone: "soon" as const, text: "SOON" };
  }

  if (state === "UPCOMING") {
    return { tone: "upcoming" as const, text: "UPCOMING" };
  }

  return { tone: "upcoming" as const, text: "ENDED" };
}

function formatMatchTime(e: any) {
  if (e.kind === "session") return null;
  const d = getAnchorDate(e);
  if (!d) return null;

  return d.toLocaleString(undefined, {
    weekday: "short",
    hour: "numeric",
    minute: "2-digit",
  });
}

function formatHorseRacingSession(e: any) {
  if (e.sport !== "horse-racing" || e.kind !== "session") return null;

  const label = e.payload?.sessionTime;
  const start = new Date(e.startDate);
  const end = new Date(e.endDate);

  if (!label || isNaN(start.getTime()) || isNaN(end.getTime())) {
    return label ?? null;
  }

  const timeOpts: Intl.DateTimeFormatOptions = {
    hour: "numeric",
    minute: "2-digit",
  };

  return `${label} Â· ${start.toLocaleTimeString(undefined, timeOpts)} â€“ ${end.toLocaleTimeString(undefined, timeOpts)}`;
}


function formatSessionRange(e: any, now = new Date()) {
  if (e.kind !== "session" || !e.startDate || !e.endDate) return null;

  const start = new Date(e.startDate);
  const end = new Date(e.endDate);

  const opts: Intl.DateTimeFormatOptions = { month: "short", day: "numeric" };
  const startLabel = start.toLocaleDateString(undefined, opts);
  const endLabel = end.toLocaleDateString(undefined, opts);

  const totalDays =
    Math.round((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24)) + 1;

  const dayIndex =
    now >= start && now <= end
      ? Math.floor(
          (now.getTime() - start.getTime()) / (1000 * 60 * 60 * 24)
        ) + 1
      : null;

  return {
    range: `${startLabel} â€“ ${endLabel}`,
    dayIndex,
    totalDays,
  };
}

/* ---------------- component ---------------- */

export default function HomeMapSnapCard({
  event,
  onClose,
}: {
  event: Event;
  onClose: () => void;
}) {
  const e: any = event;
  const vibe = getVibe(e);

  const { share, toastVisible } = useShare();

  const shareUrl = useMemo(() => {
    if (typeof window === "undefined") return "";
    const base = `${window.location.origin}${window.location.pathname}`;
    const u = new URL(base);
    u.searchParams.set("eventId", String(e.id));
    if (e.sport) u.searchParams.set("sport", String(e.sport));
    if (e.city) u.searchParams.set("city", String(e.city));
    u.searchParams.set("src", "snap_card");
    return u.toString();
  }, [e.id, e.sport, e.city]);

  const starts = useMemo(() => formatStartsLabel(e), [e]);
  const matchTime = useMemo(() => formatMatchTime(e), [e]);
  const session = useMemo(() => formatSessionRange(e), [e]);

  
  const shareText = useMemo(() => {
    // ë„ˆë¬´ ê¸¸ê²Œ ë§ê³ , OS ê³µìœ  ì‹œíŠ¸ì— ì˜ ë³´ì´ê²Œ í•œ ì¤„ ì¶”ì²œ
    const title =
      e.sport === "horse-racing"
        ? (e.code ? `${e.title} Â· ${e.code}` : e.title)
        : (e.sport === "tennis" || e.sport === "darts")
        ? e.title
        : `${e.homeTeam} vs ${e.awayTeam}`;

    const when = matchTime ? ` Â· ${matchTime}` : "";
    return `${title}${when}`;
  }, [e, matchTime]);


  const horseSession = useMemo(
    () => formatHorseRacingSession(e),
    [e]
  );

  const { pos } = useUserLocation({ enabled: true });
  const { unit } = useDistanceUnit();
  

  const distance =
    pos && e.location
      ? haversineKm(pos, e.location)
      : null;

  const mapsHref = useMemo(() => {
    const { lat, lng } = e.location ?? {};
    if (typeof lat !== "number" || typeof lng !== "number") return null;
    return `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}`;
  }, [e.location]);

  const ticketHref = useMemo(() => {
    if (!e.homepageUrl) return null;

    return (
      `/api/go/ticket` +
      `?eventId=${e.id}` +
      `&sport=${e.sport ?? ""}` +
      `&city=${e.city ?? ""}` +
      `&source=snap_card` + // âœ… ì—¬ê¸°
      `&target=${encodeURIComponent(e.homepageUrl)}`
    );
    }, [e]);


  return (
    <div
      className="
        fixed inset-x-0 z-[1000]
        bottom-[calc(env(safe-area-inset-bottom)+12px)]
        px-4
      "
      role="dialog"
    >
      <div
        className="
          max-w-3xl mx-auto
          rounded-3xl
          bg-white/85 dark:bg-black/80
          backdrop-blur-xl
          shadow-[0_-8px_40px_rgba(0,0,0,0.12)]
        "
      >
        <div className="px-5 py-5">
          {/* Header */}
          <div className="flex items-start justify-between gap-4">
            <div className="min-w-0">

              {/* Team logos (team sports only) */}
              {e.sport !== "tennis" && e.sport !== "darts" && (e.homeTeamLogo || e.awayTeamLogo) && (
                <div className="flex items-center gap-1 mb-2">
                  {e.homeTeamLogo && (
                    <img
                      src={e.homeTeamLogo}
                      alt={e.homeTeam}
                      className="w-7 h-7 rounded-full bg-white"
                    />
                  )}
                  {e.awayTeamLogo && (
                    <img
                      src={e.awayTeamLogo}
                      alt={e.awayTeam}
                      className="w-7 h-7 rounded-full bg-white -ml-2"
                    />
                  )}
                </div>
              )}

              {/* Title */}
              <p className="text-lg font-semibold leading-tight truncate">
                {e.sport === "horse-racing"
                  ? e.code
                    ? `${e.title} Â· ${e.code}`
                    : e.title
                  : e.sport === "tennis" || e.sport === "darts" // âœ… ì¶”ê°€
                  ? e.title
                  : `${e.homeTeam} vs ${e.awayTeam}`}
              </p>

              {/* Absolute time (match only) */}
              {matchTime && (
                <p className="mt-1 text-xs text-muted-foreground">
                  {matchTime}
                </p>
              )}

              {/* Session info */}
              {horseSession && (
                <p className="mt-1 text-xs text-muted-foreground">
                  {horseSession}
                </p>
              )}

              {e.kind === "session" && e.sport !== "horse-racing" && session && (
                <p className="mt-1 text-xs text-muted-foreground">
                  {session.range}
                  {session.dayIndex && (
                    <> Â· Day {session.dayIndex} of {session.totalDays}</>
                  )}
                </p>
              )}

              {/* Meta row */}
              <div className="mt-2 flex flex-wrap gap-2 text-xs text-muted-foreground">
                {typeof distance === "number" && (
                  <span>{formatDistance(distance, unit)}</span>
                )}
                {e.sport && <span>{e.sport}</span>}
              </div>

              {/* Pills */}
              <div className="mt-3 flex flex-wrap gap-2">
                <span className="inline-flex items-center gap-1 rounded-full px-2.5 py-1 text-[11px] font-medium bg-muted/60">
                  {vibe.emoji && <span>{vibe.emoji}</span>}
                  <span>{vibe.label}</span>
                </span>

                <span
                  className={[
                    "inline-flex items-center rounded-full px-2.5 py-1 text-[11px] font-semibold",
                    starts.tone === "live"
                      ? "bg-red-500/15 text-red-600"
                      : starts.tone === "soon"
                      ? "bg-amber-500/15 text-amber-700"
                      : "bg-muted/60 text-muted-foreground",
                  ].join(" ")}
                >
                  {starts.text}
                </span>
              </div>
            </div>

            <div className="flex items-center gap-3">

            {/* Share (icon button) */}
          
            <button
              onClick={() => {
                track("snapcard_share_clicked", { eventId: e.id });
                share(shareUrl, shareText);
              }}
              className="text-xs font-medium text-muted-foreground hover:text-foreground"
            >
              Share
            </button>

            {/* Close */}
            <button
              onClick={() => {
                track("snapcard_closed", { eventId: e.id });
                onClose();
              }}
              className="
                inline-flex items-center justify-center
                w-9 h-9
                rounded-full
                text-muted-foreground
                hover:text-foreground hover:bg-muted/50
                transition
              "
              aria-label="Close"
              title="Close"
            >
              âœ•
            </button>
          </div>

            {/* âœ… ë°ìŠ¤í¬íƒ‘ fallback(copy) í† ìŠ¤íŠ¸ */}
            {toastVisible && (
              <div
                className="
                  mt-2
                  w-full
                  text-center
                  text-xs
                  text-muted-foreground
                "
                role="status"
                aria-live="polite"
              >
                Link copied
              </div>
            )}
          </div>

          {/* âœ… ê¸°ì¡´ CTA ê·¸ëŒ€ë¡œ */}
          {mapsHref && (
            <div className="mt-5">
              <a
                href={mapsHref}
                target="_blank"
                rel="noreferrer"
                onClick={() => track("get_directions_clicked", { eventId: e.id })}
                className="
                  block w-full
                  rounded-2xl
                  bg-foreground
                  text-background
                  text-center
                  py-3
                  text-sm font-semibold
                  hover:opacity-90
                  transition
                "
              >
                Get directions
              </a>
            </div>
          )}

          {ticketHref && (
            <a
              href={ticketHref}
              target="_blank"
              rel="noreferrer"
              onClick={() =>
                track("official_ticket_clicked", {
                  eventId: e.id,
                  sport: e.sport,
                  city: e.city,
                })
              }
              className="
                block w-full
                rounded-2xl
                border border-border
                text-center
                py-2.5
                text-sm font-semibold
                text-foreground
                hover:bg-muted/50
                transition
              "
            >
              {e.isPaid ? "Buy official tickets" : "View official event info"}
            </a>
          )}
        </div>
      </div>
    </div>
  );
}

//src/app/app/page.tsx

"use client";

import { useEffect, useMemo, useState, useRef  } from "react";
import type { Event } from "@/types";

import HomeMapStage from "@/app/components/home/HomeMapStage";
import NowHeroScopeBar from "@/app/components/home/NowHeroScopeBar";

import HomeMapSnapCard from "@/app/components/map-hero/HomeMapSnapCard";

import LocationSheet from "@/app/components/home/LocationSheet";
import { useLocationMode } from "@/app/components/home/useLocationMode";
import { useUserLocation, haversineKm } from "@/app/components/home/useUserLocation";
import { extractRegions, extractCities } from "@/lib/eventAreas";
import { track } from "@/lib/track";
import type { HomeEventMapRef } from "@/app/components/map-hero/HomeEventMap";
import type { TimeScope } from "@/lib/nowDashboard";
import { calcCityCenter } from "@/lib/calcCityCenter";
import MapStatusPill from "@/app/components/home/MapStatusPill";
import type { AreaIndex } from "@/types/area";
import { getDefaultDurationMs } from "@/lib/eventTime";
import { getClientId } from "@/lib/clientId";
import { isReturn24h } from "@/lib/returnCheck";
import { shouldLogVisit } from "@/lib/visitThrottle";
import { detectEntryReason } from "@/lib/entryReason";

function getStartDate(e: any): Date | null {
  const raw = e.date ?? e.utcDate ?? e.startDate ?? null;
  if (!raw) return null;
  const d = new Date(raw);
  return isNaN(d.getTime()) ? null : d;
}

function startOfLocalDay(d: Date) {
  return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}
function nextWeekendRange(now: Date) {
  const base = startOfLocalDay(now);
  const day = base.getDay(); // 0 Sun ... 6 Sat
  const toSat = day === 6 ? 0 : (6 - day + 7) % 7;
  const sat = new Date(base);
  sat.setDate(sat.getDate() + toSat);
  const mon = new Date(sat);
  mon.setDate(mon.getDate() + 2);
  return { start: sat, end: mon };
}

function isInBounds(
  location: { lat: number; lng: number },
  bounds: google.maps.LatLngBoundsLiteral
) {
  return (
    location.lat <= bounds.north &&
    location.lat >= bounds.south &&
    location.lng <= bounds.east &&
    location.lng >= bounds.west
  );
}

// session = tennis tournaments, horse-racing meetings, etc.

function isSession(e: any) {
  return e.kind === "session";
}

function overlaps(aStart: Date, aEnd: Date, bStart: Date, bEnd: Date) {
  return aStart < bEnd && aEnd > bStart;
}

export default function HomePage() {
  const [areaIndex, setAreaIndex] = useState<AreaIndex[]>([]);
  const [currentEvents, setCurrentEvents] = useState<Event[]>([]); // ì´ë²ˆ ì£¼ í‘œì‹œìš©

  const { hasLocation } = useLocationMode();
  const { pos } = useUserLocation({ enabled: hasLocation });
    
  const mapRef = useRef<HomeEventMapRef | null>(null);
  const [snapEvent, setSnapEvent] = useState<Event | null>(null);

  // observer mode (no geo permission)
  const [observerRegion, setObserverRegion] = useState<string | null>(null);
  const [observerCity, setObserverCity] = useState<string | null>(null);
  const [locationOpen, setLocationOpen] = useState(false);
  const HOME_RADIUS_KM = 25;

  const [timeScope, setTimeScope] = useState<TimeScope>("today");
  const [heroExpanded, setHeroExpanded] = useState(true);
  const [sharedEventId, setSharedEventId] = useState<string | null>(null);
  const [sharedSource, setSharedSource] = useState<string | null>(null);
  const [enteredFromShare, setEnteredFromShare] = useState(false);

  const [mapViewMode, setMapViewMode] =
    useState<"user" | "global" | "observer">(
      hasLocation ? "user" : "observer"
    );

  const toggleMapView = () => {
    if (!hasLocation || !mapRef.current) return;

    if (mapViewMode === "user") {
      // ğŸŒ ì „ì²´ íˆíŠ¸ë§µìœ¼ë¡œ
      setMapViewMode("global");
      setAppliedBounds(null);
      setPendingBounds(null);

      mapRef.current.resetToAll();
      track("map_view_global_from_user");
    } else {
      // ğŸ“ ë‚´ ìœ„ì¹˜ë¡œ ë³µê·€
      setMapViewMode("user");

      if (pos) {
        mapRef.current.panTo({
          lat: pos.lat,
          lng: pos.lng,
        });
      }

      track("map_view_user_from_global");
    }
  };
  const showNowHero = hasLocation || observerCity || !hasLocation;

  const [pendingBounds, setPendingBounds] =
    useState<google.maps.LatLngBoundsLiteral | null>(null);

  const [appliedBounds, setAppliedBounds] =
    useState<google.maps.LatLngBoundsLiteral | null>(null);

  const isMobile =
    typeof window !== "undefined" && window.innerWidth < 768;

  useEffect(() => {
    // 1ï¸âƒ£ ê¸°ì¡´ ì½”ë“œ (ê·¸ëŒ€ë¡œ ë‘ )
    track("home_loaded");
    (async () => {
      // â¬…ï¸ ê³µê°„ êµ¬ì¡°ìš© (ë‚˜ë¼/ë„ì‹œ ì¶”ì¶œ)
      const areaRes = await fetch("/api/events?window=180d");
      const areaData = await areaRes.json();
      setAreaIndex(areaData.areas ?? []);

      // â¬…ï¸ ì‹¤ì œ ì§€ë„/ë§ˆì»¤ìš© (ì´ë²ˆ ì£¼)
      const curRes = await fetch("/api/events?window=7d");
      const curData = await curRes.json();
      setCurrentEvents(curData.events ?? []);
    })();
  }, []);

  useEffect(() => {
    if (hasLocation) {
      setMapViewMode("user");
    }
  }, [hasLocation]);

  // observer â†’ located ì „í™˜ ê°ì§€
  useEffect(() => {
    if (hasLocation && observerCity) {
      setObserverRegion(null);
      setObserverCity(null);
      track("observer_to_located");
    }
  }, [hasLocation]);

  // city ì„ íƒ ì‹œ
  useEffect(() => {
    if (observerCity) {
      localStorage.setItem("sportsive_observer_city", observerCity);
    }
  }, [observerCity]);

  useEffect(() => {
    if (!observerCity || !mapRef.current) return;

    // 1) âœ… ì´ë²¤íŠ¸ ì—†ì–´ë„ ì´ë™: areaIndex(center)ë¡œ ì´ë™
    const area = areaIndex.find(a => a.city === observerCity);
    if (area?.center) {
      mapRef.current.panTo(area.center);
      return;
    }

    // 2) (fallback) í˜¹ì‹œ areaIndexì— ì—†ìœ¼ë©´ ê¸°ì¡´ ë°©ì‹(ì´ë²¤íŠ¸ í‰ê· )ìœ¼ë¡œ ì´ë™
    const center = calcCityCenter(currentEvents, observerCity);
    if (center) {
      mapRef.current.panTo(center);
    }
  }, [observerCity, areaIndex, currentEvents]);

  useEffect(() => {
    if (!hasLocation || !pos || !mapRef.current) return;
    if (sharedEventId) return; // ğŸ”¥ ê³µìœ  ë§í¬ ì§„ì…ì´ë©´ ë‚´ ìœ„ì¹˜ë¡œ ì•ˆ ê°

    mapRef.current.panTo({
      lat: pos.lat,
      lng: pos.lng,
    });
  }, [hasLocation, pos, sharedEventId]);


  // âœ… ê³µê°„ êµ¬ì¡°ëŠ” areaIndex ê¸°ì¤€
  const regions = useMemo(
    () => extractRegions(areaIndex),
    [areaIndex]
  );

  const cities = useMemo(
    () => (observerRegion ? extractCities(areaIndex, observerRegion) : []),
    [areaIndex, observerRegion]
  );

  // filteredEvents useMemo ë‚´ë¶€
  const filteredEvents = useMemo(() => {
    const now = new Date();
    const todayStart = startOfLocalDay(now);

    const todayEnd = new Date(todayStart);
    todayEnd.setDate(todayEnd.getDate() + 1);

    const tomorrowStart = new Date(todayStart);
    tomorrowStart.setDate(tomorrowStart.getDate() + 1);
    const tomorrowEnd = new Date(tomorrowStart);
    tomorrowEnd.setDate(tomorrowEnd.getDate() + 1);

    const weekEnd = new Date(todayStart);
    weekEnd.setDate(weekEnd.getDate() + 7);

    const weekend = nextWeekendRange(now);

    return currentEvents.filter((e: any) => {
      /* ======================
        1ï¸âƒ£ ë‚ ì§œ íŒŒì‹±
      ====================== */
      const start = getStartDate(e);
      if (!start) return false;

      // session ì´ë²¤íŠ¸ë©´ ê¸°ê°„ ì‚¬ìš©
      const isSessionEvent = isSession(e);
      const sessionStart = isSessionEvent ? new Date(e.startDate) : start;
      const sessionEnd = isSessionEvent
        ? new Date(e.endDate)
        : new Date(start.getTime() + getDefaultDurationMs(e));

      /* ======================
        2ï¸âƒ£ ì‹œê°„ í•„í„° (scope í†µí•©)
      ====================== */

      // scopeStart / scopeEnd ê³„ì‚°
      let scopeStart: Date;
      let scopeEnd: Date;

      switch (timeScope) {
        case "today":
          scopeStart = todayStart;
          scopeEnd = todayEnd;
          break;

        case "tomorrow":
          scopeStart = tomorrowStart;
          scopeEnd = tomorrowEnd;
          break;

        case "weekend":
          scopeStart = weekend.start;
          scopeEnd = weekend.end;
          break;

        case "week":
        default:
          scopeStart = now;
          scopeEnd = weekEnd;
          break;
      }

      // session / non-session ê³µí†µ ì²˜ë¦¬
      const inScope = isSessionEvent
        ? overlaps(sessionStart, sessionEnd, scopeStart, scopeEnd)
        : start >= scopeStart && start < scopeEnd;

      if (!inScope) return false;

      /* ======================
        3ï¸âƒ£ ìœ„ì¹˜ í•„í„° (í•­ìƒ ì ìš©)
      ====================== */

      // ğŸ“ ìœ„ì¹˜ ê³µìœ  ON â†’ ë‚´ ì£¼ë³€
      if (hasLocation && pos && mapViewMode === "user") {
        if (!e.location?.lat || !e.location?.lng) return false;

        const distKm = haversineKm(pos, {
          lat: e.location.lat,
          lng: e.location.lng,
        });

        if (distKm > HOME_RADIUS_KM) return false;
      }

      // ğŸ‘€ ìœ„ì¹˜ ê³µìœ  OFF + ë„ì‹œ ì„ íƒ
      if (!hasLocation && observerCity) {
        if (e.city !== observerCity) return false;
      }

      /* ======================
        4ï¸âƒ£ Search this area
      ====================== */
      if (appliedBounds && e.location) {
        if (!isInBounds(e.location, appliedBounds)) return false;
      }

      return true;
    });
  }, [
    currentEvents,
    hasLocation,
    pos,
    observerCity,
    timeScope,
    appliedBounds,
    mapViewMode,
  ]);


  // âœ… City Pulse ì „ìš© (ìœ„ì¹˜ í•„í„° ì œê±°)
  const pulseEvents = useMemo(() => {
    const now = new Date();
    const todayStart = startOfLocalDay(now);
    const todayEnd = new Date(todayStart);
    todayEnd.setDate(todayEnd.getDate() + 1);

    return currentEvents.filter((e: any) => {
      const start = getStartDate(e);
      if (!start) return false;

      if (isSession(e)) {
        const sStart = new Date(e.startDate);
        const sEnd = new Date(e.endDate);
        return overlaps(sStart, sEnd, todayStart, todayEnd);
      }

      return start >= todayStart && start < todayEnd;
    });
  }, [currentEvents]);

  useEffect(() => {
    if (typeof window === "undefined") return;

    const params = new URLSearchParams(window.location.search);
    const eid = params.get("eventId");

    setSharedEventId(eid);
    setSharedSource(params.get("src"));

    if (eid) {
      setEnteredFromShare(true); // ğŸ”¥ ì¶”ê°€
    }
  }, []);

  // âœ… ê³µìœ  ë§í¬ ì§„ì… ì‹œ: ë‚´ ì£¼ë³€ í•„í„° ê°•ì œ í•´ì œ
  useEffect(() => {
    if (!sharedEventId) return;

    setMapViewMode("global"); // ğŸ”¥ ì´ í•œ ì¤„ì´ í•µì‹¬
  }, [sharedEventId]);


  useEffect(() => {
    if (!currentEvents.length) return;
    if (!sharedEventId) return;
    if (!mapRef.current) return;

    const ev = currentEvents.find(e => String(e.id) === sharedEventId);
    if (!ev) return;

    // ğŸ”¥ ì§€ë„ ë¨¼ì € í¬ì»¤ìŠ¤
    mapRef.current.focus(String(ev.id));

    // ğŸ”¥ ì¹´ë“œ ìƒíƒœ ë™ê¸°í™”
    setSnapEvent(ev);

    track("snapcard_opened_from_share", {
      eventId: sharedEventId,
      source: sharedSource ?? "unknown",
    });
  }, [currentEvents, sharedEventId, sharedSource]);

  useEffect(() => {
    track("home_loaded");

    if (shouldLogVisit()) {
      fetch("/api/log/visit", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          client_id: getClientId(),
          is_within_first_24h: isReturn24h(),
          entry_reason: detectEntryReason(),
        }),
      });
    }
  }, []);

  return (
    <main className="relative min-h-screen">
      {/* FULLSCREEN MAP */}
      <div className="fixed inset-0">
        <HomeMapStage
          ref={mapRef}
          events={sharedEventId ? currentEvents : filteredEvents}
          timeScope={timeScope} 
          onDiscoverFromMap={(id) => {
            const ev = filteredEvents.find(e => e.id === id) ?? null;
            setSnapEvent(ev);
          }}
          onBoundsChanged={setPendingBounds}
        />

      </div>

      {/* ğŸ” NEARBY SPORTS SCAN BUTTON (observer only) */}
      {!hasLocation && (
        <button
          onClick={() => setLocationOpen(true)}
          className="
            fixed right-4
            bottom-[calc(env(safe-area-inset-bottom)+220px)]
            z-[70]
            w-10 h-10
            rounded-full
            bg-black
            flex items-center justify-center
            shadow-lg
          "
          aria-label="Scan nearby sports"
        >
          <span className="relative">
            <span className="block w-2 h-2 bg-white rounded-full" />
            <span className="absolute inset-0 rounded-full border border-white/40 animate-ping" />
          </span>
        </button>
      )}

      {/* ğŸ”˜ MAP VIEW TOGGLE BUTTON (located user only) */}
      {hasLocation && (
        <button
          onClick={toggleMapView}
          className="
            fixed right-4
            bottom-[calc(env(safe-area-inset-bottom)+220px)]
            z-[70]
            w-10 h-10
            rounded-full
            bg-black
            flex items-center justify-center
            shadow-lg
          "
          aria-label={
            mapViewMode === "user"
              ? "View all events"
              : "Back to my location"
          }
        >
          {mapViewMode === "user" ? "ğŸŒ" : "ğŸ“"}
        </button>
      )}

      {/* NOW HERO (MAIN UI) */}
      {showNowHero && (
        <div
          className="
            fixed z-40
            left-1/2 -translate-x-1/2
            bottom-[calc(env(safe-area-inset-bottom)+12px)]
            w-full max-w-3xl
            pointer-events-none
          "
        >
          <div className="px-4 pointer-events-auto">
            {/* âœ… í•­ìƒ ë³´ì´ëŠ” í•„í„° ë°” */}
            <div
              className="
                h-14
                rounded-full
                bg-background/80
                backdrop-blur
                ring-1 ring-border/40
                flex items-center justify-center
              "
              onClick={() => setHeroExpanded(true)}
            >
              {/* ğŸ‘‰ NowHeroì—ì„œ í•„í„° UIë§Œ ë¶„ë¦¬í•´ì„œ ì»´í¬ë„ŒíŠ¸í™” */}
              <NowHeroScopeBar
                scope={timeScope}
                onScopeChange={setTimeScope}
              />
            </div>
          </div>
        </div>
      )}

      {/* LOCATION SHEET (observer only) */}
      {locationOpen && (
        <LocationSheet
          regions={regions}
          cities={cities}
          observerRegion={observerRegion}
          onPickRegion={(r) => {
            // âœ… ALL ì„ íƒ (LocationSheetì—ì„œ nullì„ ë³´ëƒ„)
            if (r === null) {
              setObserverRegion(null);
              setObserverCity(null);

              setAppliedBounds(null);
              setPendingBounds(null);

              setHeroExpanded(false); // ë¦¬ìŠ¤íŠ¸ ì ‘ê³ 
              setSnapEvent(null);     // ì¹´ë“œ ë‹«ê³ 

              mapRef.current?.resetToAll(); // ğŸ”¥ ì§€ë„ + ìƒíƒœ ë¦¬ì…‹

              track("home_region_all_selected");
              setLocationOpen(false);
              return;
            }

            // âœ… íŠ¹ì • region ì„ íƒ
            setObserverRegion(r);
            setObserverCity(null);
            track("home_region_selected", { r });
          }}

          onPickCity={(c) => {
            setObserverCity(c);
            setLocationOpen(false);
          }}

          onClose={() => setLocationOpen(false)}
        />
      )}

      {/* ğŸŸ¢ MAP STATUS PILL (today only) */}
      {timeScope === "today" && filteredEvents.length > 0 && (
        <MapStatusPill
          events={filteredEvents}
          scope={mapViewMode}
        />
      )}

      {snapEvent && (
        <HomeMapSnapCard
          event={snapEvent}
          onClose={() => {
            mapRef.current?.closeSnap();  // ğŸ”´ ì§€ë„ ì›ìƒë³µê·€
            setSnapEvent(null);
          }}
        />
      )}

    </main>
  );
}
